<?php namespace  Moody {class  Configuration {private static$A=array();public static function load($B){}public static function set($C,$D){return self::$A[strtolower($C)]=$D;}public static function get($C,$E=null){$C=strtolower($C);if(isset(self::$A[$C]))return self::$A[$C];return$E;}}}namespace  Moody {use  Moody\TokenHandlers\ClassEntry;use  Moody\TokenHandlers\ClassFetcher;use  Moody\TokenHandlers\NamespaceFetcher;class  ConstantContainer {private static$F=array();public static function initialize(){foreach(get_defined_constants()as$G=>$H)if(!self::isDefined($G))self::define($G,$H);}public static function getConstant($I,ClassEntry$J=null){$I=strtolower($I);if(strpos($I,'::')){$I=explode('::',$I,2);if(!($K=NamespaceFetcher::getInstance()->getCurrentNamespace())||($K&&!($J=ClassFetcher::getInstance()->fetchClass($K.'\\'.$I[0])))){$J=ClassFetcher::getInstance()->fetchClass($I[0]);}if($J){do{if(isset($J->F[$I[1]]))return$J->F[$I[1]];}while($J=$J->L);}return;}if($J){do{if(isset($J->F[$I]))return$J->F[$I];}while($J=$J->L);return;}$K=NamespaceFetcher::getInstance()->getCurrentNamespace();if($K&&isset(self::$F[$K."\\".$I]))return self::$F[$K."\\".$I];if(isset(self::$F[$I]))return self::$F[$I];}public static function isDefined($I,ClassEntry$J=null){$I=strtolower($I);if($J){do{if(isset($J->F[$I]))return true;}while($J=$J->L);return false;}if(strpos($I,'::')){$I=explode('::',$I,2);if(!($K=NamespaceFetcher::getInstance()->getCurrentNamespace())||($K&&!($J=ClassFetcher::getInstance()->fetchClass($K.'\\'.$I[0])))){$J=ClassFetcher::getInstance()->fetchClass($I[0]);}if($J){do{if(isset($J->F[$I[1]]))return true;}while($J=$J->L);}return false;}$K=NamespaceFetcher::getInstance()->getCurrentNamespace();if($K&&isset(self::$F[$K."\\".$I]))return true;return isset(self::$F[$I]);}public static function define($I,$D,ClassEntry$J=null,$K=false){if($J){$J->F[strtolower($I)]=$D;}else {if($K)$I=NamespaceFetcher::getInstance()->getCurrentNamespace()."\\".strtolower($I);else $I=strtolower($I);self::$F[$I]=$D;}}public static function undefine($I){$I=strtolower($I);if(isset(self::$F[$I]))unset(self::$F[$I]);}}}namespace  Moody {const  END_TOKEN_NO_EXECUTE = 1;const  END_TOKEN_EXECUTE = 2;class  MultiTokenInstruction {private static$M=array();private static$N=array();private$O;private$P;private$Q=2;public function __construct(Token$O,$J){self::$M[$J][]=$this;self::$N[$J][]=$this;$this->O=$O;}public static function setEndToken(Token$O,$J){if(!isset(self::$N[$J])||!self::$N[$J])throw new InstructionProcessorException('End token of type '.$J.' while not active',$O);end(self::$N[$J]);self::$N[$J][key(self::$N[$J])]->P=$O;unset(self::$N[$J][key(self::$N[$J])]);}public function getToken(){return$this->O;}public function getEndToken(){return$this->P;}public function setEndTokenAction($R){$this->Q=$R;}public function getEndTokenAction(){return$this->Q;}public static function getAll($J){return self::$M[$J];}}}namespace  Moody {interface InstructionHandler{public static function getInstance();public function execute(Token$O,$S,TokenHandlers\InstructionProcessor$T,TokenVM$U);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$O,$S,TokenHandlers\InstructionProcessor$T,TokenVM$U);}interface InlineInstructionHandler extends InstructionHandler{public function execute(Token$O,$S,TokenHandlers\InstructionProcessor$T,TokenVM$U=null,$V=0);}interface DefaultInstructionHandler extends InstructionHandler{public function execute(Token$O,$S,TokenHandlers\InstructionProcessor$T,TokenVM$U=null,$V=0);public function canExecute(Token$O,$S,TokenHandlers\InstructionProcessor$T);}}namespace  Moody {class  InstructionProcessorException extends \Exception {private$O;public function __construct($message,Token$O){$this->message=$message;$this->O=$O;}public function __toString(){$B='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString()."\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->O;return$B;}}}namespace  Moody {class  MoodyException extends \Exception {public function __toString(){$B='Moody encountered an unexpected error and can not continue.'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace: '."\r\n".$this->getTraceAsString();return$B;}}}namespace  Moody {define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);define('T_EQUAL',16394);define('T_CURLY_BRACKET_OPEN',16395);define('T_CURLY_BRACKET_CLOSE',16396);define('T_EOF',16397);define('T_SELF',16398);define('T_PARENT',16399);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class  Token {public$W=0;public$X=0;public$Y=0;public$Z="Unknown";public$a=0;public$content="";public$b=array();private static$c=0;private static$d=0;private static$e=array(347=>"T_ABSTRACT",271=>"T_AND_EQUAL",362=>"T_ARRAY",292=>"T_ARRAY_CAST",326=>"T_AS",313=>"T_BAD_CHARACTER",279=>"T_BOOLEAN_AND",278=>"T_BOOLEAN_OR",290=>"T_BOOL_CAST",331=>"T_BREAK",329=>"T_CASE",338=>"T_CATCH",312=>"T_CHARACTER",354=>"T_CLASS",364=>"T_CLASS_C",298=>"T_CLONE",374=>"T_CLOSE_TAG",16388=>"T_COMMA",370=>"T_COMMENT",273=>"T_CONCAT_EQUAL",335=>"T_CONST",315=>"T_CONSTANT_ENCAPSED_STRING",332=>"T_CONTINUE",379=>"T_CURLY_OPEN",16395=>"T_CURLY_BRACKET_OPEN",16396=>"T_CURLY_BRACKET_CLOSE",296=>"T_DEC",324=>"T_DECLARE",330=>"T_DEFAULT",383=>"T_DIR",274=>"T_DIV_EQUAL",306=>"T_DNUMBER",317=>"T_DO",371=>"T_DOC_COMMENT",378=>"T_DOLLAR_OPEN_CURLY_BRACES",16384=>"T_DOT",360=>"T_DOUBLE_ARROW",294=>"T_DOUBLE_CAST",380=>"T_DOUBLE_COLON",316=>"T_ECHO",303=>"T_ELSE",302=>"T_ELSEIF",352=>"T_EMPTY",314=>"T_ENCAPSED_AND_WHITESPACE",325=>"T_ENDDECLARE",321=>"T_ENDFOR",323=>"T_ENDFOREACH",304=>"T_ENDIF",328=>"T_ENDSWITCH",319=>"T_ENDWHILE",377=>"T_END_HEREDOC",16397=>"T_EOF",16394=>"T_EQUAL",260=>"T_EVAL",300=>"T_EXIT",357=>"T_EXTENDS",16390=>"T_FALSE",369=>"T_FILE",346=>"T_FINAL",320=>"T_FOR",16392=>"T_FORCED_WHITESPACE",322=>"T_FOREACH",334=>"T_FUNCTION",367=>"T_FUNC_C",342=>"T_GLOBAL",333=>"T_GOTO",353=>"T_HALT_COMPILER",372=>"T_OPEN_TAG",16387=>"T_ROUND_BRACKET_CLOSE",16386=>"T_ROUND_BRACKET_OPEN",16393=>"T_SEMICOLON",307=>"T_STRING",16389=>"T_TRUE",16385=>"T_UNKNOWN",309=>"T_VARIABLE",375=>"T_WHITESPACE");public function __construct(){$this->W=self::$c++;}public static function tokenize($code,$f=null){$c=token_get_all($code);if(!$c)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$g=array();self::$d++;foreach($c as$O){$h=new Token;$h->Y=self::$d;$h->Z=$f;if(is_array($O)){$h->X=$O[0];$h->content=$O[1];$h->a=$O[2];switch(strtolower($h->content)){case'true':$h->X=16389;break;case'false':$h->X=16390;break;case'null':$h->X=16391;break;case'self':$h->X=16398;break;case'parent':$h->X=16399;break;}}else {$h->content=$O;$h->a=-1;switch($O){case'.':$h->X=16384;break;case'(':$h->X=16386;break;case')':$h->X=16387;break;case',':$h->X=16388;break;case';':$h->X=16393;break;case'=':$h->X=16394;break;case'{':$h->X=16395;break;case'}':$h->X=16396;break;default:$h->X=16385;}}$g[]=$h;}return$g;}public static function getName($i){return isset(self::$e[$i])?self::$e[$i]:$i;}public function __toString(){$B='Type: '.self::getName($this->X)."\r\n";$B.='Content: '.$this->content."\r\n";if($this->Z!="Unknown"){$B.='Origin: '.$this->Z."\r\n";$B.='Line: '.$this->a."\r\n";}return$B;}public static function makeEvaluatable($D){if(is_string($D))return"'".str_replace("'","\'",$D)."'";if(is_int($D)||is_float($D))return$D;if($D===true)return"true";if($D===false)return"false";if($D===null)return"null";}public static function makeTokenFromValue($D,$j="Moody Tokenizer Value"){$O=new Token;$O->Z=$j;if($D instanceof Variable){$O->X=309;$O->content=$D->I;}else {$O->content=var_export($D,true);switch(gettype($D)){case"string":$O->X=315;break;case"integer":$O->X=305;break;case"double":$O->X=306;break;case"boolean":$O->X=$D?16389:16390;break;case"NULL":$O->X=16391;break;default:throw new MoodyException('Unsupported value of type '.gettype($D));}}return$O;}}}namespace  Moody {interface TokenHandler{public static function getInstance();public function execute(Token$O,TokenVM$U);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$O,TokenVM$U);}}namespace  Moody {const  MOODY_VERSION = "1.0";class  TokenVM {const  NEXT_TOKEN = 1;const  QUIT = 2;const  NEXT_HANDLER = 4;const  ERROR = 8;const  REEXECUTE_TOKEN = 16;const  REEXECUTE_HANDLER = 32;const  JUMP = 64;const  CLEAR_RETVAL = 128;const  CLEAR_ERROR = 256;const  DELETE_TOKEN = 512;const  JUMP_WITHOUT_DELETE_TOKEN = 1024;private static$k=array();private$l=array();private$m=array();private$n=array();private$o=null;public function __construct(){$this->l=self::$k;}public function execute($n){if(!$n)throw new VMException('Virtual machine received empty token array');$this->n=$n;foreach($this->n as$O){if(isset($this->l[$O->X])){foreach($this->l[$O->X]as$p){$q=clone$O;if(is_callable(array($p,'register')))$p->register($O,$this);if($O!=$q)throw new VMException('Token corrupted in register step',$O,$q);}reset($this->l[$O->X]);}}reset($this->n);$r=array();nextToken:if(!($O=current($this->n)))goto quit;$s=$O->W;next($this->n);$t=clone$O;executeToken:$this->m[$s]=true;$u=0;nextHandler:if(isset($this->l[$O->X])){$p=current($this->l[$O->X]);next($this->l[$O->X]);}else {$r[]=$O;goto nextToken;}executeHandler:$v=$p->execute($O,$this);if($v&128)$u=$v;else $u|=$v;doRetval:if($u&32){$u^=32;goto executeHandler;}if($u&4){$u^=4;if(current($this->l[$O->X])!==false)goto nextHandler;}if($u&16){reset($this->l[$O->X]);$u^=16;goto executeToken;}if(!($u&512))$r[]=$O;if($u&2)goto quit;if($u&8&&!($u&256))throw new VMException('Token handler returned an error',$O,$t);if(($u&64)||($u&1024)){if(!($this->o instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$O,$t);if(!in_array($this->o,$this->n))throw new VMException('Cannot jump to new token as it is not specified in current token array',$O,$t);$w=array_search($this->o,$this->n);if($w<key($this->n)){while(prev($this->n)!=$this->o);}else if($w>key($this->n)){if($u&1024){$r[]=current($this->n);while(($x=next($this->n))!=$this->o){$r[]=$x;}}else {while(next($this->n)!=$this->o);}}}if($u&1){reset($this->l[$O->X]);goto nextToken;}throw new VMException('Token handler did not specify an action for the virtual machine',$O,$t);quit:return$r;}public function hasExecuted($s){return isset($this->m[$s]);}public static function globalRegisterTokenHandler($i,TokenHandler$y){if(!($y instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($i).' is invalid');if(!isset(self::$k[$i]))self::$k[$i]=array($y);else self::$k[$i][]=$y;}public static function globalUnregisterTokenHandler($i,TokenHandler$y){if(!isset(self::$k[$i])||($w=array_search(self::$l[$i]))===false)return;unset(self::$k[$i][$w]);}public function registerTokenHandler($i,TokenHandler$y){if(!($y instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($i).' is invalid');if(!isset($this->l[$i]))$this->l[$i]=array($y);else $this->l[$i][]=$y;}public function unregisterTokenHandler($i,TokenHandler$y){if(!isset($this->l[$i])||($w=array_search($y,$this->l[$i]))===false)return;unset($this->l[$i][$w]);}public function jump(Token$O){$this->o=$O;}public function insertTokenArray($n){reset($n);$z=current($n);while($O=current($this->n)){$i0[]=$O;unset($this->n[key($this->n)]);}foreach($n as$O){if(isset($this->l[$O->X])){$w=key($this->l[$O->X]);foreach($this->l[$O->X]as$p){$q=clone$O;if(is_callable(array($p,'register')))$p->register($O,$this);if($O!=$q)throw new VMException('Token corrupted in register step',$O,$q);}reset($this->l[$O->X]);while(key($this->l[$O->X])!==$w)next($this->l[$O->X]);}$this->n[]=$O;}foreach($i0 as$O)$this->n[]=$O;$w=array_search($z,$this->n);while(key($this->n)!=$w)prev($this->n);}public function getTokenArray(){return$this->n;}public function moveTo(Token$O){$w=array_search($O,$this->n);if($w<key($this->n)){while(prev($this->n)!=$O);}else if($w>key($this->n)){while(next($this->n)!=$O);}}}}namespace  Moody {class  VMException extends \Exception {private$O;private$t;public function __construct($message,Token$O=null,Token$t=null){$this->message=$message;$this->O=$O;$this->t=$t;}public function __toString(){$B='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString();if($this->O instanceof Token){$B.="\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->O;}if($this->t instanceof Token){$B.="\r\n";$B.='Current token before modification by token handlers:'."\r\n";$B.=(string)$this->t;}return$B;}}}namespace  Moody\TokenHandlers {use  Moody\InstructionHandlerWithRegister;use  Moody\InlineInstructionHandler;use  Moody\DefaultInstructionHandler;use  Moody\TokenHandlerWithRegister;use  Moody\TokenVM;use  Moody\Token;use  Moody\InstructionProcessorException;use  Moody\Configuration;use  Moody\ConstantContainer;use  Moody\InstructionHandler;class  InstructionProcessor implements TokenHandlerWithRegister {private static$i1=null;private$l=array();private$i2=array();const  EXECUTE_TYPE_INLINE = 1;const  EXECUTE_TYPE_DEFAULT = 2;public static function getInstance(){if(!self::$i1)new self;return self::$i1;}private function __construct(){self::$i1=$this;TokenVM::globalRegisterTokenHandler(370,$this);foreach(get_declared_classes()as$J){if(in_array('Moody\InstructionHandler',class_implements($J)))$J::getInstance();}}public function callInstruction($S,TokenVM$U,$i3=0,$i4=array(),$i5=""){$O=new Token;$O->X=370;$O->content="#.".$S." ".$i5;$O->Z="Moody Instruction Processor Direct Call";$O->b=$i4;return$i3==1?$this->inlineExecute($O):$this->execute($O,$U);}public function execute(Token$O,TokenVM$U){$content=str_replace(array("//","/*","*/","#"),"",$O->content);$i6=array();$i7=0;if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i6)){$i8=strtolower($i6[1]);if(substr($i8,0,1)=='.')$i8=substr($i8,1);if(isset($this->l[$i8])){$i7=$this->l[$i8]->execute($O,$i6[1],$this,$U);$O->b=array();goto end;}else if($this->i2){foreach($this->i2 as$y){if($y->canExecute($O,$i6[1],$this)){$i7=$y->execute($O,$i6[1],$this,$U,2);$O->b=array();goto end;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i6[1].'"',$O);}else if(Configuration::get('deletecomments',true))$i7=512;end:return (4|1)^$i7;}public function register(Token$O,TokenVM$U){$content=str_replace(array("//","/*","*/","#"),"",$O->content);$i6=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i6)){$i8=strtolower($i6[1]);if(substr($i8,0,1)=='.')$i8=substr($i8,1);if(isset($this->l[$i8])&&$this->l[$i8]instanceof InstructionHandlerWithRegister){$this->l[$i8]->register($O,$i6[1],$this,$U);$O->b=array();}}}private function inlineExecute(Token$O){$content=str_replace(array("//","/*","*/","#"),"",$O->content);$i6=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i6)){$i8=strtolower($i6[1]);if(substr($i8,0,1)=='.')$i8=substr($i8,1);if(isset($this->l[$i8])){if(!($this->l[$i8]instanceof InlineInstructionHandler))throw new InstructionProcessorException($i6[1].' does not support inline execution',$O);$u=$this->l[$i8]->execute($O,$i6[1],$this,null,1);$O->b=array();return$u;}else if($this->i2){foreach($this->i2 as$y){if(!($y instanceof InlineInstructionHandler))continue;if($y->canExecute($O,$i6[1],$this)){$u=$y->execute($O,$i6[1],$this,null,2|1);$O->b=array();return$u;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i6[1].'"',$O);}}public function registerHandler($i8,InstructionHandler$y){if(!($y instanceof InstructionHandler))throw new InstructionProcessorException('Handler for instruction "'.$i8.'" is invalid');$this->l[$i8]=$y;}public function registerDefaultHandler(DefaultInstructionHandler$y){if(!($y instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default handler '.get_class($y).' is invalid');$this->i2[]=$y;}public function parseArguments(Token$i9,$S,$i10){if($i9->b)return$i9->b;if($i10)$i11=str_split($i10);else $i11=array();if(!strpos($i9->content,$S))throw new InstructionProcessorException('Token corrupted',$i9);if(substr($i9->content,0,2)=='/*')$content=substr($i9->content,2,strrpos($i9->content,'*/')-2);else if(substr($i9->content,0,1)=='#')$content=substr($i9->content,1);else $content=substr($i9->content,2);$i12=substr($content,strpos($content,$S)+strlen($S));$c=Token::tokenize('<?php '.$i12.' ?>','Moody Argument Parser');foreach($c as$O)if($O->X==16388)$i13=true;$i14=0;$i15=0;$i4=$i16=array();$i17=null;parseArgs:foreach($c as$O){if(isset($i18))goto parseArg;if($O->X==372||$O->X==374||$O->X==16386||$O->X==16387||$O->X==375||in_array($O,$i16))continue;switch($O->X){case 307:if(($i19=current($c))&&$i19->X==380){$i20=next($c);$i21=$O->content."::".$i20->content;if(ConstantContainer::isDefined($i21)){if($i17!==null)$i17.=ConstantContainer::getConstant($i21);else $i17=ConstantContainer::getConstant($i21);$i16=array($i19,$i20);break;}}if(ConstantContainer::isDefined($O->content))if($i17!==null)$i17.=ConstantContainer::getConstant($O->content);else $i17=ConstantContainer::getConstant($O->content);else $i17.=$O->content;break;case 315:$i17.=eval('return '.$O->content.';');break;case 16389:if($i17!==null)$i17.=true;else $i17=true;break;case 16390:if($i17!==null)$i17.=false;else $i17=false;break;case 305:if($i17!==null)$i17.=(int)$O->content;else $i17=(int)$O->content;break;case 306:if($i17!==null)$i17.=(float)$O->content;else $i17=(float)$O->content;break;case 16391:if($i17!==null)$i17.=null;else $i17=null;break;case 384:$i22="";$i23=prev($c);if($i23&&$i23->X==307){$i22=$i23->content.$O->content;end($i4);unset($i4[key($i4)]);next($c);}while($i24=next($c)){if($i24->X!=384&&$i24->X!=307&&$i24->X!=380)break;$i22.=$i24->content;$i16[]=$i24;}if(ConstantContainer::isDefined($i22))if($i17!==null)$i17.=ConstantContainer::getConstant($i22);else $i17=ConstantContainer::getConstant($i22);else $i17.=$i22;break;case 370:if($i17!==null)$i17.=$this->inlineExecute($O);else $i17=$this->inlineExecute($O);break;case 16388:goto parseArg;default:if($i17!==null)$i17.=$O->content;else $i17=$O->content;}if(isset($i13))continue;parseArg:if(!isset($i11[$i14+$i15])||!$i11[$i14+$i15]){$i4[]=$i17;}else if($i11[$i14+$i15]=='?'){$i15++;goto parseArg;}else {switch(strtolower($i11[$i14+$i15])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i11[$i14+$i15],$i9);case'n':if(is_numeric($i17)&&is_string($i17))$i4[]=(float)$i17;else if(is_int($i17)||is_float($i17)||$i17===null)$i4[]=$i17;else throw new InstructionProcessorException('Illegal argument '.($i14+1).' for '.$S.': '.gettype($i17).' '.(string)$i17.' given, number expected',$i9);break;case's':if(is_string($i17)||$i17===null)$i4[]=$i17;else throw new InstructionProcessorException('Illegal argument '.($i14+1).' for '.$S.': '.gettype($i17).' '.(string)$i17.' given, string expected',$i9);break;case'b':if(is_bool($i17)||$i17===null)$i4[]=$i17;else throw new InstructionProcessorException('Illegal argument '.($i14+1).' for '.$S.': '.gettype($i17).' '.(string)$i17.' given, bool expected',$i9);break;case'x':$i4[]=$i17;}}$i17=null;$i14++;if(isset($i18))break;}if($i17!==null){$i18=true;goto parseArgs;}if((strpos($i10,'?')!==false&&$i14<strpos($i10,'?'))||($i14<count($i11)&&strpos($i10,'?')===false))throw new InstructionProcessorException($S.' expects '.count($i11).' arguments, '.$i14.' given',$i9);return$i9->b=$i4;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;use  Moody\Configuration;class  DocCommentHandler implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(371,$this);}public function execute(Token$O,TokenVM$U){if(Configuration::get('deletecomments',false))return 4|1|512;return 4|1;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;class  EOFDeleter implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(16397,$this);}public function execute(Token$O,TokenVM$U){return 512|1;}}}namespace  Moody\TokenHandlers {use  Moody\Token;use  Moody\TokenVM;use  Moody\TokenHandler;class  OpenTagHandler implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(372,$this);}public function execute(Token$O,TokenVM$U){if($O->content=='<?'||$O->content=='<%')$O->content='<?php ';return 4|1;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;use  Moody\Configuration;class  VariableHandler implements TokenHandler {private static$i1=null;private$i25=array();private$i26="A";public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(309,$this);TokenVM::globalRegisterTokenHandler(359,$this);}public function execute(Token$O,TokenVM$U){static$i27=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(Configuration::get('compressvariables',false)&&!in_array($O->content,$i27)){if($O->X==359){if(!Configuration::get('compressproperties',false))return 4|1;$n=$U->getTokenArray();$i28=current($n);if($i28->X!=307)goto end;while($i29=next($n)){if($i29->X==375)continue;if($i29->X==16386)goto end;break;}$i30=$i28;$i30->content='$'.$i30->content;}else $i30=$O;if(!isset($this->i25[$i30->content])){if(!Configuration::get('compressproperties',false)){$n=$U->getTokenArray();prev($n);while($i29=prev($n)){switch($i29->X){case 348:$i31=true;goto map;default:if(!isset($i31)&&isset($i32))goto end;goto map;case 343:case 344:case 345:$i32=true;case 375:case 16392:continue 2;}}}map:do{$this->mapVariable($i30->content,is_int($this->i26)?'$i'.$this->i26:'$'.$this->i26);if($this->i26==="Z")$this->i26="a";else if($this->i26==="z")$this->i26=0;else if(is_int($this->i26))$this->i26++;else $this->i26=chr(ord($this->i26)+1);}while(count(array_keys($this->i25,$this->i25[$i30->content]))>1);}$i30->content=isset($i28)?substr($this->i25[$i30->content],1):$this->i25[$i30->content];}end:return 4|1;}public function mapVariable($i33,$i34){return$this->i25[$i33]=$i34;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Configuration;use  Moody\Token;class  WhitespaceHandler implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){TokenVM::globalRegisterTokenHandler(375,$this);TokenVM::globalRegisterTokenHandler(316,$this);TokenVM::globalRegisterTokenHandler(309,$this);TokenVM::globalRegisterTokenHandler(333,$this);TokenVM::globalRegisterTokenHandler(303,$this);TokenVM::globalRegisterTokenHandler(381,$this);TokenVM::globalRegisterTokenHandler(335,$this);TokenVM::globalRegisterTokenHandler(299,$this);TokenVM::globalRegisterTokenHandler(288,$this);TokenVM::globalRegisterTokenHandler(341,$this);TokenVM::globalRegisterTokenHandler(307,$this);TokenVM::globalRegisterTokenHandler(354,$this);TokenVM::globalRegisterTokenHandler(357,$this);TokenVM::globalRegisterTokenHandler(343,$this);TokenVM::globalRegisterTokenHandler(344,$this);TokenVM::globalRegisterTokenHandler(345,$this);TokenVM::globalRegisterTokenHandler(346,$this);TokenVM::globalRegisterTokenHandler(348,$this);TokenVM::globalRegisterTokenHandler(334,$this);TokenVM::globalRegisterTokenHandler(336,$this);TokenVM::globalRegisterTokenHandler(329,$this);TokenVM::globalRegisterTokenHandler(376,$this);TokenVM::globalRegisterTokenHandler(16393,$this);TokenVM::globalRegisterTokenHandler(377,$this);TokenVM::globalRegisterTokenHandler(331,$this);TokenVM::globalRegisterTokenHandler(332,$this);TokenVM::globalRegisterTokenHandler(340,$this);TokenVM::globalRegisterTokenHandler(339,$this);TokenVM::globalRegisterTokenHandler(356,$this);TokenVM::globalRegisterTokenHandler(355,$this);TokenVM::globalRegisterTokenHandler(358,$this);}}public function execute(Token$O,TokenVM$U){if(Configuration::get('deletewhitespaces',false)){switch($O->X){case 375:$n=$U->getTokenArray();if(($i29=current($n))&&$i29->X==377)$this->insertForcedWhitespace($U,true);return 4|1|512;case 316:case 336:case 343:case 344:case 345:case 348:case 346:case 329:case 332:case 331:case 339:$n=$U->getTokenArray();if($i29=current($n)){if($i29->X!=375)return 4|1;else if(($i29=next($n))&&$i29->X!=315&&$i29->X!=309)$this->insertForcedWhitespace($U);}break;case 309:$n=$U->getTokenArray();if($i29=current($n)){if($i29->X!=375)return 4|1;else if(($i29=next($n))&&($i29->X==326||$i29->X==288))$this->insertForcedWhitespace($U);}break;case 333:case 381:case 335:case 299:case 288:case 341:case 354:case 357:case 334:case 376:case 340:case 356:case 355:case 358:$this->insertForcedWhitespace($U);break;case 303:$n=$U->getTokenArray();if($i29=current($n)){if($i29->X!=375)return 4|1;else if(($i29=next($n))&&$i29->X!=379)$this->insertForcedWhitespace($U);}break;case 307:$n=$U->getTokenArray();if($i29=current($n)){if($i29->X!=375)return 4|1;else if(($i29=next($n))&&($i29->X==357||$i29->X==341||$i29->X==288||$i29->X==326||$i29->X==358))$this->insertForcedWhitespace($U);}break;case 16393:$n=$U->getTokenArray();prev($n);$i29=prev($n);if($i29->X==377)$this->insertForcedWhitespace($U,true);break;case 377:$n=$U->getTokenArray();if(($i29=current($n))&&$i29->X!=16393)$this->insertForcedWhitespace($U,true);break;}}end:return 4|1;}private function insertForcedWhitespace(TokenVM$U,$i35=false){$O=new Token;$O->content=$i35?"\r\n":" ";$O->X=16392;$O->Z="Moody WhitespaceHandler";$U->insertTokenArray(array($O));}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;class  ClassEntry {public$i36=array();public$I="";public$i37="";public$L=null;public$F=array();}class  ClassFetcher implements TokenHandler {private static$i1=null;private$i38=null;private$i39=array();public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(354,$this);}public function execute(Token$O,TokenVM$U){$n=$U->getTokenArray();$i40=354;$J=new ClassEntry;while($i41=next($n)){switch($i41->X){case 358:$i40=358;break;case 357:$i40=357;break;case 307:switch($i40){case 354:$i42=strtolower($i41->content);if($K=NamespaceFetcher::getInstance()->getCurrentNamespace())$J->I=$K."\\".$i42;else $J->I=$i42;$J->i37=$i42;break;case 357:$J->L=$this->fetchClass(strtolower($i41->content));break;case 358:$J->i36[]=strtolower($i41->content);}break;case 16395:break 2;}}$this->i38=$this->i39[$J->I]=$J;$i43=ScopeFetcher::getInstance();$i43->addLeaveCallback(array($this,'leaveClass'),$i43->getDepth()+1);$U->jump($i41);return 1024|4|1;}public function getCurrentClass(){return$this->i38;}public function leaveClass(){$this->i38=null;}public function fetchClass($I){$I=strtolower($I);switch($I){case"self":return$this->i38;case"parent":return$this->i38?$this->i38->L:null;default:return isset($this->i39[$I])?$this->i39[$I]:null;}}public function registerClass($I,ClassEntry$i44){$this->i39[$I]=$i44;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;use  Moody\ConstantContainer;class  ConstantDefinitionHandler implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(335,$this);}public function execute(Token$O,TokenVM$U){$n=$U->getTokenArray();$i45=false;$J=ClassFetcher::getInstance()->getCurrentClass();while($i41=next($n)){switch($i41->X){case 16393:break 2;case 16394:$i45=true;case 375:continue 2;case 307:if($i45){if(ConstantContainer::isDefined($i41->content)){ConstantContainer::define($I,ConstantContainer::getConstant($i41->content),$J,true);}else {ConstantContainer::define($I,$i41->content,$J,true);}}else {$I=$i41->content;}break;case 305:ConstantContainer::define($I,(int)$i41->content,$J,true);break;case 306:ConstantContainer::define($I,(float)$i41->content,$J,true);break;case 16389:ConstantContainer::define($I,true,$J,true);break;case 16390:ConstantContainer::define($I,false,$J,true);break;case 315:ConstantContainer::define($I,eval('return ('.$i41->content.');'),$J,true);break;case 16388:$i45=false;}}$U->jump($i41);return 1024|4|1;}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;class  NamespaceFetcher implements TokenHandler {private static$i1=null;private$i46=array("");public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(381,$this);}public function execute(Token$O,TokenVM$U){if($O->X==381){$n=$U->getTokenArray();$K="";for($O=current($n);;$O=next($n)){switch($O->X){case 384:if($K)$K.="\\";break;case 307:$K.=strtolower($O->content);break;case 16393:$U->registerTokenHandler(16397,$this);break 2;case 16395:$i43=ScopeFetcher::getInstance();$i43->addLeaveCallback(array($this,'leaveNamespace'),$i43->getDepth()+1);break 2;}}$this->i46[]=$K;$U->jump($O);return 1024|4|1;}else {$this->leaveNamespace();if(count($this->i46)==1)$U->unregisterTokenHandler(16397,$this);return 512|1;}}public function leaveNamespace(){end($this->i46);unset($this->i46[key($this->i46)]);}public function getCurrentNamespace(){return end($this->i46);}}}namespace  Moody\TokenHandlers {use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;class  ScopeFetcher implements TokenHandler {private static$i1=null;private$i47=0;private$i48=array();private$i49=array();public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(16395,$this);TokenVM::globalRegisterTokenHandler(16396,$this);}public function execute(Token$O,TokenVM$U){if($O->X==16395){$this->i47++;if(isset($this->i48[$this->i47])){foreach($this->i48[$this->i47]as$W=>$i50){call_user_func($i50,$this->i47);unset($this->i48[$W]);}}}else {if(isset($this->i49[$this->i47])){foreach($this->i49[$this->i47]as$W=>$i50){call_user_func($i50,$this->i47);unset($this->i49[$W]);}}$this->i47--;}return 4|1;}public function addEnterCallback($i50,$i47){$this->i48[$i47][]=$i50;}public function addLeaveCallback($i50,$i47){$this->i49[$i47][]=$i50;}public function getDepth(){return$this->i47;}}}namespace  Moody\TokenHandlers {use  Moody\Token;use  Moody\TokenVM;use  Moody\TokenHandler;use  Moody\ConstantContainer;use  Moody\Configuration;use  Moody\InstructionHandlers\Macro;use  Moody\TokenHandlers\InstructionProcessor;class  SymbolSubstitutionHandler implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(307,$this);TokenVM::globalRegisterTokenHandler(384,$this);TokenVM::globalRegisterTokenHandler(16398,$this);TokenVM::globalRegisterTokenHandler(16399,$this);}public function execute(Token$O,TokenVM$U){if(!Configuration::get("autosubstitutesymbols",true))return 4|1;$n=$U->getTokenArray();$i51=0;$i52=$O;switch($O->X){case 16398:case 16399:$J=ClassFetcher::getInstance()->getCurrentClass();if($O->X==16399)$J=$J->L;for($i41=current($n);;$i41=next($n)){if($i41->X==380)continue;if($i41->X!=307)break 2;if(ConstantContainer::isDefined($i41->content,$J)&&is_scalar($H=ConstantContainer::getConstant($i41->content,$J))){$O->content=Token::makeEvaluatable($H);$U->jump(next($n));return 64|1;}break 2;}break;case 384:$O=current($n);next($n);case 307:$i53=$O->content;if($i54=Macro::getMacro(strtolower($i53))){$i5="";if($i54->numArgs()){$i55=0;for($i41=current($n);;$i41=next($n)){switch($i41->X){case 16386:$i55++;if($i55>1)$i5.=$i41->content;break;case 16387:if(!(--$i55))break 2;default:$i5.=$i41->content;}}$U->moveTo(next($n));}InstructionProcessor::getInstance()->callInstruction($i54->I,$U,0,array(),$i5);return 512|1;}for($i41=current($n);;$i41=next($n)){switch($i41->X){case 380:$K=NamespaceFetcher::getInstance()->getCurrentNamespace();if(!$K||!($J=ClassFetcher::getInstance()->fetchClass($K."\\".$i53)))$J=ClassFetcher::getInstance()->fetchClass($i53);continue 2;case 307:if(isset($J)&&ConstantContainer::isDefined($i41->content,$J)&&is_scalar($H=ConstantContainer::getConstant($i41->content,$J))){$i52->content=Token::makeEvaluatable($H);$U->jump(next($n));return 64|1;}else {$i53.=$i41->content;continue 2;}case 384:$i53.="\\";continue 2;default:break 2;}}if(ConstantContainer::isDefined($i53)&&is_scalar($H=ConstantContainer::getConstant($i53))){$i52->content=Token::makeEvaluatable($H);$U->jump($i41);return 1|64;}break;}return 1|4;}}}namespace  Moody\TokenHandlers {use  Moody\ConstantContainer;use  Moody\TokenHandler;use  Moody\TokenVM;use  Moody\Token;class  UseStatementParser implements TokenHandler {private static$i1=null;public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}private function __construct(){TokenVM::globalRegisterTokenHandler(340,$this);}public function execute(Token$O,TokenVM$U){$i56=ClassFetcher::getInstance();if($i56->getCurrentClass())return 4|1;$n=$U->getTokenArray();$i40=340;$i57="";$i58="";for($i41=current($n);;$i41=next($n)){switch($i41->X){case 326:$i40=326;break;case 384:if($i40==326){if($i58)$i58.="\\";}else if($i57){$i57.="\\";}break;case 307:if($i40==326)$i58.=$i41->content;else $i57.=$i41->content;break;case 16388:case 16393:if(!($J=$i56->fetchClass($i57)))break 2;if($i40==340){$K=NamespaceFetcher::getInstance()->getCurrentNamespace();if($K)$i58=$K."\\".$J->i37;else $i58=$J->i37;}$i56->registerClass(strtolower($i58),$J);if($i41->X==16388){$i58=$i57="";break;}break 2;}}$U->jump($i41);return 1024|1;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  BooleanCastHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'x');if($V&1)return (bool)$i4[0];$O->content=Token::makeEvaluatable((bool)$i4[0]);return 0;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\DefaultInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  CallHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){if($V&2){$i59=substr($S,0,1)=='.'?substr($S,1):$S;$i4=$T->parseArguments($O,$S,'');$i4=array_merge(array($i59),$i4);}else {$i4=$T->parseArguments($O,$S,'s');$i59=$i4[0];}if(strpos($i59,'::')){$i60=explode('::',$i59,2);$i59=array($i60[0],$i60[1]);if(!method_exists($i60[0],$i60[1]))throw new InstructionProcessorException($i4[0].'() does not exist',$O);}else if(!function_exists($i59))throw new InstructionProcessorException($i4[0].'() does not exist',$O);if(!is_callable($i59))throw new InstructionProcessorException($i4[0].'() is not callable from the current scope',$O);$i61=$i4;unset($i61[0]);$D=call_user_func_array($i59,$i61);if($V&1)return$D;$O->content=Token::makeEvaluatable($D);return 0;}public function canExecute(Token$O,$S,InstructionProcessor$T){if(substr($S,0,1)=='.')$S=substr($S,1);if(strpos($S,'::')){$i60=explode('::',$S,2);if(!method_exists($i60[0],$i60[1]))return false;}else if(!function_exists($S))return false;return true;}}}namespace  Moody\InstructionHandlers {use  Moody\Configuration;use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  ConfigurationHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'s?x');if(!isset($i4[1])){if($V&1)return Configuration::get($i4[0],null);$O->content=Token::makeEvaluatable(Configuration::get($i4[0],null));return 0;}else Configuration::set($i4[0],$i4[1]);return 512;}}}namespace  Moody\InstructionHandlers {use  Moody\DefaultInstructionHandler;use  Moody\InstructionHandler;use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  GetConstantHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){if($V&2)$i4=array(substr($S,0,1)=='.'?substr($S,1):$S);else $i4=$T->parseArguments($O,$S,'s');if(!ConstantContainer::isDefined($i4[0]))throw new InstructionProcessorException($S.': Undefined constant: '.$i4[0],$O);$i62=ConstantContainer::getConstant($i4[0]);if($V&1)return$i62;$O->content=Token::makeEvaluatable($i62);return 0;}public function canExecute(Token$O,$S,InstructionProcessor$T){if($T->parseArguments($O,$S,''))return false;if(!ConstantContainer::isDefined(substr($S,0,1)=='.'?substr($S,1):$S))return false;return true;}}}namespace  Moody\InstructionHandlers {use  Moody\DefaultInstructionHandler;use  Moody\ConstantContainer;use  Moody\InstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;use  Moody\InstructionProcessorException;class  DefineHandler implements InstructionHandler, DefaultInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){if($V&2){$i4=$T->parseArguments($O,$S,'sx');$G=substr($S,0,1)=='.'?substr($S,1):$S;$i63=array('(',')','+','-','*','/','|','&','^','>>','<<');$i64="";foreach($i4 as$i65=>$i66){if(!$i65)continue;if(!is_int($i66)&&!in_array($i66,$i63))$i67=false;$i64.=$i66;}if(isset($i67))$D=$i64;else if(($D=eval('return ('.$i64.');'))===false)throw new InstructionProcessorException('Math syntax error');switch($i4[0]){case'=':ConstantContainer::define($G,$D);break;case'.=':ConstantContainer::define($G,ConstantContainer::getConstant($G).$D);break;case'+=':ConstantContainer::define($G,ConstantContainer::getConstant($G)+$D);break;case'-=':ConstantContainer::define($G,ConstantContainer::getConstant($G)-$D);break;case'*=':ConstantContainer::define($G,ConstantContainer::getConstant($G)*$D);break;case'/=':ConstantContainer::define($G,ConstantContainer::getConstant($G)/$D);break;case'|=':ConstantContainer::define($G,ConstantContainer::getConstant($G)|$D);break;case'^=':ConstantContainer::define($G,ConstantContainer::getConstant($G)^$D);break;case'&=':ConstantContainer::define($G,ConstantContainer::getConstant($G)&$D);break;case'>>=':ConstantContainer::define($G,ConstantContainer::getConstant($G)>>$D);break;case'<<=':ConstantContainer::define($G,ConstantContainer::getConstant($G)<<$D);break;}}else {$i4=$T->parseArguments($O,$S,'sx');ConstantContainer::define($i4[0],$i4[1]);}return 512;}public function canExecute(Token$O,$S,InstructionProcessor$T){$i4=$T->parseArguments($O,$S,'');$i63=array('=','.=','+=','-=','*=','/=','|=','&=','^=','<<=','>>=');if(in_array($i4[0],$i63)&&!($i4[0]!='='&&!ConstantContainer::isDefined(substr($S,0,1)=='.'?substr($S,1):$S)))return true;return false;}}}namespace  Moody\InstructionHandlers {use  Moody\TokenHandlers\ClassFetcher;use  Moody\InstructionHandler;use  Moody\InstructionProcessorException;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;use  Moody\TokenHandlers\ClassEntry;class  DumpClassEntryHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('dumpclassentry',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'?s');if($i4){$J=ClassFetcher::getInstance()->fetchClass($i4[0]);}else {$J=ClassFetcher::getInstance()->getCurrentClass();}if(!$J)throw new InstructionProcessorException('Unknown class specified',$O);$this->dumpClassEntry($J,"");}private function dumpClassEntry(ClassEntry$J,$i68){echo"Moody Class Entry ".$J->I." {".'
';if($J->L){echo$i68."Extends ";$this->dumpClassEntry($J->L,$i68."\t");}if($J->i36){echo$i68."Implements {".'
';foreach($J->i36 as$i69){echo$i68."\t".$i69.'
';}echo$i68."}".'
';}if($J->F){foreach($J->F as$I=>$D){echo$i68.$I." = ".$D.'
';}}echo$i68."}".'
';}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  EchoHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'x');foreach($i4 as$i66)echo (string)$i66;return 512;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  ElseHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getToken()==$O){if(!($i8->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endif?',$O);$i70=$i8;}}foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getEndToken()==$O){if($i8->getEndTokenAction()==1){$i70->setEndTokenAction(1);$U->jump($i70->getEndToken());return 512|64;}}}return 512;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){MultiTokenInstruction::setEndToken($O,'if');new MultiTokenInstruction($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  ElseIfHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getToken()==$O){if(!($i8->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endif?',$O);$i70=$i8;}}foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getEndToken()==$O){if($i8->getEndTokenAction()==1){$i70->setEndTokenAction(1);$U->jump($i70->getEndToken());return 512|64;}}}return IfHandler::getInstance()->execute($O,$S,$T,$U);}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){MultiTokenInstruction::setEndToken($O,'if');new MultiTokenInstruction($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\ConstantContainer;class  EndLongDefineHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endlongdefine',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){return 512;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){MultiTokenInstruction::setEndToken($O,'longDefine');}}}namespace  Moody\InstructionHandlers {use  Moody\TokenHandlers\InstructionProcessor;use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenVM;use  Moody\MultiTokenInstruction;class  EndIfHandler implements InstructionHandlerWithRegister {private static$i1;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){return 512;}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){MultiTokenInstruction::setEndToken($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  EvalHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'s?bb');if(!isset($i4[1])||$i4[1]===true){if(!strpos($i4[0],'<?')){$i71=true;$n=Token::tokenize('<?php '.$i4[0].' ?>',$S.' code');}else $n=Token::tokenize($i4[0],$S.' code');$U=new TokenVM();$n=$U->execute($n);if(isset($i71)){reset($n);unset($n[key($n)]);end($n);unset($n[key($n)]);}$i4[0]="";foreach($n as$i72){$i4[0].=$i72->content;}}$i73=eval($i4[0]);if($i73!==null){if($V&1)return$i73;$O->content=!isset($i4[2])||$i4[2]===true?Token::makeEvaluatable($i73):$i73;return 0;}return 512;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  ExitHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){return 2|512;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InstructionHandler;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  GotoHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');$i74=LabelHandler::getLabel($i4[0]);if(!($i74 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i4[0],$O);$U->jump($i74);return 64|512;}}}namespace  Moody\InstructionHandlers {use  Moody\END_TOKEN_ELSE;use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\InstructionHandlerWithRegister;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  IfHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'x');foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getToken()==$O){if(!($i8->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endif?',$O);$i75="";$i73=false;foreach($i4 as$i66){if(is_string($i66)&&strlen($i66)&&strtolower($i66)!=="true"&&strtolower($i66)!=="false"){$c=Token::tokenize('<?php '.$i66.' ?>');if($c[1]->X==307)$i66=Token::makeEvaluatable($i66);}else if(is_string($i66)&&!strlen($i66))$i66="''";if($i66===true)$i66="true";else if($i66===false)$i66="false";else if($i66===null)$i66="null";$i75.=$i66;}$i73=eval('return (int) (bool) ('.$i75.');');if($i73===1){$i8->setEndTokenAction(1);return 512;}if($i73===false)throw new InstructionProcessorException('If-condition '.$i75.' is invalid',$O);$i8->setEndTokenAction(2);$U->jump($i8->getEndToken());return 64|512;}}return 8;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){new MultiTokenInstruction($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\InstructionHandlerWithRegister;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  IfDefHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getToken()==$O){if(!($i8->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endif?',$O);if(ConstantContainer::isDefined($i4[0])){$i8->setEndTokenAction(1);return 512;}$U->jump($i8->getEndToken());$i8->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){new MultiTokenInstruction($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\InstructionHandlerWithRegister;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  IfNotDefHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');foreach(MultiTokenInstruction::getAll('if')as$i8){if($i8->getToken()==$O){if(!($i8->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endif?',$O);if(!ConstantContainer::isDefined($i4[0])){$i8->setEndTokenAction(1);return 512;}$U->jump($i8->getEndToken());$i8->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){new MultiTokenInstruction($O,'if');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  IncludeHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');if(!file_exists($i4[0]))throw new InstructionProcessorException($i4[0].' does not exist',$O);if(!is_readable($i4[0]))throw new InstructionProcessorException($i4[0].' is not readable - Make sure Moody has the rights to read it',$O);$f=file_get_contents($i4[0]);$c=Token::tokenize($f,$i4[0]);switch($c[0]->X){case 372:unset($c[0]);break;case 311:$O=new Token;$O->X=374;$O->content=" ?>";$i76=array($O);foreach($c as$O)$i76[]=$O;$c=$i76;}switch(end($c)->X){case 374:unset($c[key($c)]);break;case 311:$O=new Token;$O->X=372;$O->content="<?php ";$c[]=$O;}$O=new Token;$O->X=16397;$O->content=$i4[0];$c[]=$O;$U->insertTokenArray($c);return 512;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  InputHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('input',$this);InstructionProcessor::getInstance()->registerHandler('getinput',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'?n');if(!defined('STDIN')||!is_resource(\STDIN))throw new InstructionProcessorException('No input stream available',$O);$D=fread(\STDIN,isset($i4[0])?$i4[0]:1024);if($V&1)return$D;$O->content=Token::makeEvaluatable($D);return 0;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  IsDefinedHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'s');if(ConstantContainer::isDefined($i4[0])){if($V&1)return true;$O->content=Token::makeEvaluatable(true);}else {if($V&1)return false;$O->content=Token::makeEvaluatable(false);}return 0;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  LabelHandler implements InstructionHandlerWithRegister {private static$i1=null;private static$i77=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){return 512;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');if(isset(self::$i77[$i4[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i4[0].'" (first definition at '.self::$i77[$i4[0]]->Z.':'.self::$i77[$i4[0]]->a,$O);self::$i77[$i4[0]]=$O;}public static function getLabel($I){if(isset(self::$i77[$I]))return self::$i77[$I];}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;use  Moody\InstructionProcessorException;use  Moody\MultiTokenInstruction;use  Moody\ConstantContainer;class  LongDefineHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('longdefine',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'s');foreach(MultiTokenInstruction::getAll('longDefine')as$i8){if($i8->getToken()==$O){$P=$i8->getEndToken();if(!($P instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$S.' - Probably you forgot an endLongDefine?',$O);$c=$U->getTokenArray();$i78="";while($O=current($c)){if($O==$P){ConstantContainer::define($i4[0],$i78);$U->jump($O);return 64|512;}$i78.=$O->content;next($c);}}}return 8;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){new MultiTokenInstruction($O,'longDefine');}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  MacroHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){if(strtolower($S)=='.macro'){if($V&1)throw new InstructionProcessorException($S.' does not support inline execution',$O);$i4=$T->parseArguments($O,$S,'ss');if(!strlen($i4[0]))throw new InstructionProcessorException('Macro name cannot be empty',$O);$i4[0]=strtolower($i4[0]);$i54=new Macro($i4[0],$i4[1]);$T->registerHandler($i4[0],$this);unset($i4[0],$i4[1]);foreach($i4 as$i66)$i54->addArgument($i66);return 512;}$i79=substr(strtolower($S),1);$i54=Macro::getMacro($i79);if(!$i54)throw new InstructionProcessorException('Call to bad macro',$O);$i11="";for($i80=0;$i80<$i54->numArgs();$i80++)$i11.='x';$i4=$T->parseArguments($O,$S,$i11);if($V&1){$code="";foreach($i54->buildCode($i4)as$O)$code.=$O->content;return$code;}else $U->insertTokenArray($i54->buildCode($i4));return 512;}}class  Macro {public$I="";private$code="";private$i81=array();private static$i82=array();public function __construct($I,$code){$this->I=$I;$this->code=$code;self::$i82[$I]=$this;}public function addArgument($i83){$this->i81[]=$i83;}public function numArgs(){return count($this->i81);}public function buildCode($i4=array()){$i80=0;$code=$this->code;foreach($this->i81 as$i66){$code=str_replace($i66,$i4[$i80],$code);$i80++;}$c=Token::tokenize('<?php '.$code,'Macro '.$this->I);unset($c[0]);return$c;}public static function getMacro($I){if(isset(self::$i82[$I]))return self::$i82[$I];}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenHandlers\VariableHandler;use  Moody\TokenVM;class  MapVariableHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$O);VariableHandler::getInstance()->mapVariable($i4[0],$i4[1]);return 512;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  NumberCastHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'x');if($V&1)return (float)$i4[0];$O->content=Token::makeEvaluatable((float)$i4[0]);return 0;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  RaiseErrorHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'s');throw new InstructionProcessorException($i4[0],$O);}}}namespace  Moody\InstructionHandlers {use  Moody\Configuration;use  Moody\InstructionHandlerWithRegister;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  RegisterConfigurationHandler implements InstructionHandlerWithRegister {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('registerconfiguration',$this);InstructionProcessor::getInstance()->registerHandler('registerconfig',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){return 512;}public function register(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'sx');Configuration::set($i4[0],$i4[1]);}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InlineInstructionHandler;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  StringCastHandler implements InlineInstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U=null,$V=0){$i4=$T->parseArguments($O,$S,'x');if($V&1)return (string)$i4[0];$O->content=Token::makeEvaluatable((string)$i4[0]);return 0;}}}namespace  Moody\InstructionHandlers {use  Moody\InstructionProcessorException;use  Moody\InstructionHandler;use  Moody\ConstantContainer;use  Moody\Token;use  Moody\TokenHandlers\InstructionProcessor;use  Moody\TokenVM;class  UndefineHandler implements InstructionHandler {private static$i1=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$i1)self::$i1=new self;return self::$i1;}public function execute(Token$O,$S,InstructionProcessor$T,TokenVM$U){$i4=$T->parseArguments($O,$S,'s');if(!ConstantContainer::isDefined($i4[0]))throw new InstructionProcessorException($S.': Undefined constant: '.$i4[0],$O);ConstantContainer::undefine($i4[0]);return 512;}}}?>