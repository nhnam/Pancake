<?php namespace  Moody {class  Configuration {private static$A=array();private static$B=array();public static function load($C){}public static function set($D,$E,TokenVM$F=null){$D=strtolower($D);if(isset(self::$B[$D])){call_user_func(self::$B[$D],$E,$F);}return self::$A[$D]=$E;}public static function get($D,$G=null){$D=strtolower($D);if(isset(self::$A[$D]))return self::$A[$D];return$G;}public static function registerCallback($D,$G,$H,$I=true){if(!is_callable($H)){throw new MoodyException('Bad configuration callback');}$D=strtolower($D);self::$B[$D]=$H;if($I){$H(isset(self::$A[$D])?self::$A[$D]:$G);}}}}namespace  Moody {use Moody\TokenHandlers\ClassEntry;use Moody\TokenHandlers\ClassFetcher;use Moody\TokenHandlers\NamespaceFetcher;class  ConstantContainer {private static$J=array();public static function initialize(){foreach(get_defined_constants()as$K=>$L)if(!self::isDefined($K))self::define($K,$L);}public static function getConstant($M,ClassEntry$N=null){$M=strtolower($M);if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return$N->J[$M[1]];}while($N=$N->P);}return;}if($N){do{if(isset($N->J[$M]))return$N->J[$M];}while($N=$N->P);return;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return self::$J[$O."\\".$M];if(isset(self::$J[$M]))return self::$J[$M];}public static function isDefined($M,ClassEntry$N=null){$M=strtolower($M);if($N){do{if(isset($N->J[$M]))return true;}while($N=$N->P);return false;}if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return true;}while($N=$N->P);}return false;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return true;return isset(self::$J[$M]);}public static function define($M,$E,ClassEntry$N=null,$O=false){if($N){$N->J[strtolower($M)]=$E;}else {if($O)$M=NamespaceFetcher::getInstance()->getCurrentNamespace()."\\".strtolower($M);else $M=strtolower($M);self::$J[$M]=$E;}}public static function undefine($M){$M=strtolower($M);if(isset(self::$J[$M]))unset(self::$J[$M]);}}}namespace  Moody {const  END_TOKEN_NO_EXECUTE = 1;const  END_TOKEN_EXECUTE = 2;class  MultiTokenInstruction {private static$Q=array();private static$R=array();private$S;private$T;private$U=2;public function __construct(Token$S,$N){self::$Q[$N][]=$this;self::$R[$N][]=$this;$this->S=$S;}public static function setEndToken(Token$S,$N){if(!isset(self::$R[$N])||!self::$R[$N])throw new InstructionProcessorException('End token of type '.$N.' while not active',$S);end(self::$R[$N]);self::$R[$N][key(self::$R[$N])]->T=$S;unset(self::$R[$N][key(self::$R[$N])]);}public function getToken(){return$this->S;}public function getEndToken(){return$this->T;}public function setEndTokenAction($V){$this->U=$V;}public function getEndTokenAction(){return$this->U;}public static function getAll($N){return self::$Q[$N];}}}namespace  Moody {interface InstructionHandler{public static function getInstance();public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InlineInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);}interface DefaultInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);public function canExecute(Token$S,$W,TokenHandlers\InstructionProcessor$X);}}namespace  Moody {class  InstructionProcessorException extends \Exception {private$S;public function __construct($message,Token$S){$this->message=$message;$this->S=$S;}public function __toString(){$C='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString()."\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;return$C;}}}namespace  Moody {class  MoodyException extends \Exception {public function __toString(){$C='Moody encountered an unexpected error and can not continue.'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace: '."\r\n".$this->getTraceAsString();return$C;}}}namespace  Moody {define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);define('T_EQUAL',16394);define('T_CURLY_BRACKET_OPEN',16395);define('T_CURLY_BRACKET_CLOSE',16396);define('T_EOF',16397);define('T_SELF',16398);define('T_PARENT',16399);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class  Token {public$a=0;public$b=0;public$c=0;public$d="Unknown";public$e=0;public$content="";public$f=array();private static$g=0;private static$h=0;private static$i=array(347=>"T_ABSTRACT",271=>"T_AND_EQUAL",362=>"T_ARRAY",292=>"T_ARRAY_CAST",326=>"T_AS",313=>"T_BAD_CHARACTER",279=>"T_BOOLEAN_AND",278=>"T_BOOLEAN_OR",290=>"T_BOOL_CAST",331=>"T_BREAK",329=>"T_CASE",338=>"T_CATCH",312=>"T_CHARACTER",354=>"T_CLASS",364=>"T_CLASS_C",298=>"T_CLONE",374=>"T_CLOSE_TAG",16388=>"T_COMMA",370=>"T_COMMENT",273=>"T_CONCAT_EQUAL",335=>"T_CONST",315=>"T_CONSTANT_ENCAPSED_STRING",332=>"T_CONTINUE",379=>"T_CURLY_OPEN",16395=>"T_CURLY_BRACKET_OPEN",16396=>"T_CURLY_BRACKET_CLOSE",296=>"T_DEC",324=>"T_DECLARE",330=>"T_DEFAULT",383=>"T_DIR",274=>"T_DIV_EQUAL",306=>"T_DNUMBER",317=>"T_DO",371=>"T_DOC_COMMENT",378=>"T_DOLLAR_OPEN_CURLY_BRACES",16384=>"T_DOT",360=>"T_DOUBLE_ARROW",294=>"T_DOUBLE_CAST",380=>"T_DOUBLE_COLON",316=>"T_ECHO",303=>"T_ELSE",302=>"T_ELSEIF",352=>"T_EMPTY",314=>"T_ENCAPSED_AND_WHITESPACE",325=>"T_ENDDECLARE",321=>"T_ENDFOR",323=>"T_ENDFOREACH",304=>"T_ENDIF",328=>"T_ENDSWITCH",319=>"T_ENDWHILE",377=>"T_END_HEREDOC",16397=>"T_EOF",16394=>"T_EQUAL",260=>"T_EVAL",300=>"T_EXIT",357=>"T_EXTENDS",16390=>"T_FALSE",369=>"T_FILE",346=>"T_FINAL",320=>"T_FOR",16392=>"T_FORCED_WHITESPACE",322=>"T_FOREACH",334=>"T_FUNCTION",367=>"T_FUNC_C",342=>"T_GLOBAL",333=>"T_GOTO",353=>"T_HALT_COMPILER",372=>"T_OPEN_TAG",16387=>"T_ROUND_BRACKET_CLOSE",16386=>"T_ROUND_BRACKET_OPEN",16393=>"T_SEMICOLON",307=>"T_STRING",16389=>"T_TRUE",16385=>"T_UNKNOWN",309=>"T_VARIABLE",375=>"T_WHITESPACE");public function __construct(){$this->a=self::$g++;}public static function tokenize($code,$j=null){$g=token_get_all($code);if(!$g)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$k=array();self::$h++;foreach($g as$S){$l=new Token;$l->c=self::$h;$l->d=$j;if(is_array($S)){$l->b=$S[0];$l->content=$S[1];$l->e=$S[2];switch(strtolower($l->content)){case'true':$l->b=16389;break;case'false':$l->b=16390;break;case'null':$l->b=16391;break;case'self':$l->b=16398;break;case'parent':$l->b=16399;break;}}else {$l->content=$S;$l->e=-1;switch($S){case'.':$l->b=16384;break;case'(':$l->b=16386;break;case')':$l->b=16387;break;case',':$l->b=16388;break;case';':$l->b=16393;break;case'=':$l->b=16394;break;case'{':$l->b=16395;break;case'}':$l->b=16396;break;default:$l->b=16385;}}$k[]=$l;}return$k;}public static function getName($m){return isset(self::$i[$m])?self::$i[$m]:$m;}public function __toString(){$C='Type: '.self::getName($this->b)."\r\n";$C.='Content: '.$this->content."\r\n";if($this->d!="Unknown"){$C.='Origin: '.$this->d."\r\n";$C.='Line: '.$this->e."\r\n";}return$C;}public static function makeEvaluatable($E){if(is_string($E))return"'".str_replace("'","\'",$E)."'";if(is_int($E)||is_float($E))return$E;if($E===true)return"true";if($E===false)return"false";if($E===null)return"null";}public static function makeTokenFromValue($E,$n="Moody Tokenizer Value"){$S=new Token;$S->d=$n;if($E instanceof Variable){$S->b=309;$S->content=$E->M;}else {$S->content=var_export($E,true);switch(gettype($E)){case"string":$S->b=315;break;case"integer":$S->b=305;break;case"double":$S->b=306;break;case"boolean":$S->b=$E?16389:16390;break;case"NULL":$S->b=16391;break;default:throw new MoodyException('Unsupported value of type '.gettype($E));}}return$S;}}}namespace  Moody {interface TokenHandler{public static function getInstance();public function execute(Token$S,TokenVM$Y);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$S,TokenVM$Y);}}namespace  Moody {const  MOODY_VERSION = "1.0";class  TokenVM {const  NEXT_TOKEN = 1;const  QUIT = 2;const  NEXT_HANDLER = 4;const  ERROR = 8;const  REEXECUTE_TOKEN = 16;const  REEXECUTE_HANDLER = 32;const  JUMP = 64;const  CLEAR_RETVAL = 128;const  CLEAR_ERROR = 256;const  DELETE_TOKEN = 512;const  JUMP_WITHOUT_DELETE_TOKEN = 1024;private static$o=array();private$p=array();private$q=array();private$r=null;public function __construct(){$this->p=self::$o;}public function execute($q){if(!$q)throw new VMException('Virtual machine received empty token array');$this->q=$q;foreach($this->q as$S){if(isset($this->p[$S->b])){foreach($this->p[$S->b]as$s){if(is_callable(array($s,'register'))){$t=clone$S;$s->register($S,$this);if($S!=$t)throw new VMException('Token corrupted in register step',$S,$t);}}reset($this->p[$S->b]);}}reset($this->q);$u=array();nextToken:if(!($S=current($this->q)))goto quit;$v=$S->a;next($this->q);$w=clone$S;executeToken:$x=0;nextHandler:if(isset($this->p[$S->b])){$s=current($this->p[$S->b]);next($this->p[$S->b]);}else {$u[]=$S;goto nextToken;}executeHandler:$y=$s->execute($S,$this);if($y&128)$x=$y;else $x|=$y;doRetval:if($x&32){$x^=32;goto executeHandler;}if($x&4){$x^=4;if(current($this->p[$S->b])!==false)goto nextHandler;}if($x&16){reset($this->p[$S->b]);$x^=16;goto executeToken;}if(!($x&512))$u[]=$S;if($x&2)goto quit;if($x&8&&!($x&256))throw new VMException('Token handler returned an error',$S,$w);if(($x&64)||($x&1024)){if(!($this->r instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$S,$w);if(!in_array($this->r,$this->q))throw new VMException('Cannot jump to new token as it is not specified in current token array',$S,$w);$z=array_search($this->r,$this->q);if($z<key($this->q)){while(prev($this->q)!=$this->r);}else if($z>key($this->q)){if($x&1024){$u[]=current($this->q);while(($i0=next($this->q))!=$this->r){$u[]=$i0;}}else {while(next($this->q)!=$this->r);}}}if($x&1){reset($this->p[$S->b]);goto nextToken;}throw new VMException('Token handler did not specify an action for the virtual machine',$S,$w);quit:return$u;}public static function globalRegisterTokenHandler($m,TokenHandler$i1){if(!($i1 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($m).' is invalid');if(!isset(self::$o[$m]))self::$o[$m]=array($i1);else self::$o[$m][]=$i1;}public static function globalUnregisterTokenHandler($m,TokenHandler$i1){if(!isset(self::$o[$m])||($z=array_search($i1,self::$o[$m]))===false)return;unset(self::$o[$m][$z]);if(!self::$o[$m])unset(self::$o[$m]);}public function registerTokenHandler($m,TokenHandler$i1){if(!($i1 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($m).' is invalid');if(!isset($this->p[$m]))$this->p[$m]=array($i1);else $this->p[$m][]=$i1;}public function unregisterTokenHandler($m,TokenHandler$i1){if(!isset($this->p[$m])||($z=array_search($i1,$this->p[$m]))===false)return;unset($this->p[$m][$z]);if(!$this->p[$m])unset($this->p[$m]);}public function jump(Token$S){$this->r=$S;}public function insertTokenArray($q){reset($q);$i2=current($q);while($S=current($this->q)){$i3[]=$S;unset($this->q[key($this->q)]);}foreach($q as$S){if(isset($this->p[$S->b])){$i4=current($this->p[$S->b]);foreach($this->p[$S->b]as$s){if(is_callable(array($s,'register'))){$t=clone$S;$s->register($S,$this);if($S!=$t)throw new VMException('Token corrupted in register step',$S,$t);}}reset($this->p[$S->b]);if($i4!==current($this->p[$S->b])){while(next($this->p[$S->b])!==$i4);}}$this->q[]=$S;}foreach($i3 as$S)$this->q[]=$S;if(current($this->q)!==$i2){while(prev($this->q)!==$i2);}}public function getTokenArray(){return$this->q;}public function moveTo(Token$S){$z=array_search($S,$this->q);if($z<key($this->q)){while(prev($this->q)!=$S);}else if($z>key($this->q)){while(next($this->q)!=$S);}}}}namespace  Moody {class  VMException extends \Exception {private$S;private$w;public function __construct($message,Token$S=null,Token$w=null){$this->message=$message;$this->S=$S;$this->w=$w;}public function __toString(){$C='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString();if($this->S instanceof Token){$C.="\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;}if($this->w instanceof Token){$C.="\r\n";$C.='Current token before modification by token handlers:'."\r\n";$C.=(string)$this->w;}return$C;}}}namespace  Moody\TokenHandlers {use Moody\InstructionHandlerWithRegister;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\TokenHandlerWithRegister;use Moody\TokenVM;use Moody\Token;use Moody\InstructionProcessorException;use Moody\Configuration;use Moody\ConstantContainer;use Moody\InstructionHandler;class  InstructionProcessor implements TokenHandlerWithRegister {private static$i5=null;private$p=array();private$i6=array();const  EXECUTE_TYPE_INLINE = 1;const  EXECUTE_TYPE_DEFAULT = 2;public static function getInstance(){if(!self::$i5)new self;return self::$i5;}private function __construct(){self::$i5=$this;TokenVM::globalRegisterTokenHandler(370,$this);foreach(get_declared_classes()as$N){if(in_array('Moody\InstructionHandler',class_implements($N)))$N::getInstance();}}public function callInstruction($W,TokenVM$Y,$i7=0,$i8=array(),$i9=""){$S=new Token;$S->b=370;$S->content="#.".$W." ".$i9;$S->d="Moody Instruction Processor Direct Call";$S->f=$i8;return$i7==1?$this->inlineExecute($S):$this->execute($S,$Y);}public function execute(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i10=array();$i11=0;if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i10)){$i12=strtolower($i10[1]);if(substr($i12,0,1)=='.')$i12=substr($i12,1);if(isset($this->p[$i12])){$i11=$this->p[$i12]->execute($S,$i10[1],$this,$Y);$S->f=array();goto end;}else if($this->i6){foreach($this->i6 as$i1){if($i1->canExecute($S,$i10[1],$this)){$i11=$i1->execute($S,$i10[1],$this,$Y,2);$S->f=array();goto end;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i10[1].'"',$S);}else if(Configuration::get('deletecomments',true))$i11=512;end:return (4|1)^$i11;}public function register(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i10=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i10)){$i12=strtolower($i10[1]);if(substr($i12,0,1)=='.')$i12=substr($i12,1);if(isset($this->p[$i12])&&$this->p[$i12]instanceof InstructionHandlerWithRegister){$this->p[$i12]->register($S,$i10[1],$this,$Y);$S->f=array();}}}private function inlineExecute(Token$S){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i10=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i10)){$i12=strtolower($i10[1]);if(substr($i12,0,1)=='.')$i12=substr($i12,1);if(isset($this->p[$i12])){if(!($this->p[$i12]instanceof InlineInstructionHandler))throw new InstructionProcessorException($i10[1].' does not support inline execution',$S);$x=$this->p[$i12]->execute($S,$i10[1],$this,null,1);$S->f=array();return$x;}else if($this->i6){foreach($this->i6 as$i1){if(!($i1 instanceof InlineInstructionHandler))continue;if($i1->canExecute($S,$i10[1],$this)){$x=$i1->execute($S,$i10[1],$this,null,2|1);$S->f=array();return$x;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i10[1].'"',$S);}}public function registerHandler($i12,InstructionHandler$i1){if(!($i1 instanceof InstructionHandler))throw new InstructionProcessorException('Handler for instruction "'.$i12.'" is invalid');$this->p[$i12]=$i1;}public function registerDefaultHandler(DefaultInstructionHandler$i1){if(!($i1 instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default handler '.get_class($i1).' is invalid');$this->i6[]=$i1;}public function parseArguments(Token$i13,$W,$i14){if($i13->f)return$i13->f;if($i14)$i15=str_split($i14);else $i15=array();if(!strpos($i13->content,$W))throw new InstructionProcessorException('Token corrupted',$i13);if(substr($i13->content,0,2)=='/*')$content=substr($i13->content,2,strrpos($i13->content,'*/')-2);else if(substr($i13->content,0,1)=='#')$content=substr($i13->content,1);else $content=substr($i13->content,2);$i16=substr($content,strpos($content,$W)+strlen($W));$g=Token::tokenize('<?php '.$i16.' ?>','Moody Argument Parser');foreach($g as$S)if($S->b==16388)$i17=true;$i18=0;$i19=0;$i8=$i20=array();$i21=null;parseArgs:foreach($g as$S){if(isset($i22))goto parseArg;if($S->b==372||$S->b==374||$S->b==16386||$S->b==16387||$S->b==375||in_array($S,$i20))continue;switch($S->b){case 307:if(($i23=current($g))&&$i23->b==380){$i24=next($g);$i25=$S->content."::".$i24->content;if(ConstantContainer::isDefined($i25)){if($i21!==null)$i21.=ConstantContainer::getConstant($i25);else $i21=ConstantContainer::getConstant($i25);$i20=array($i23,$i24);break;}}if(ConstantContainer::isDefined($S->content))if($i21!==null)$i21.=ConstantContainer::getConstant($S->content);else $i21=ConstantContainer::getConstant($S->content);else $i21.=$S->content;break;case 315:$i21.=eval('return '.$S->content.';');break;case 16389:if($i21!==null)$i21.=true;else $i21=true;break;case 16390:if($i21!==null)$i21.=false;else $i21=false;break;case 305:if($i21!==null)$i21.=(int)$S->content;else $i21=(int)$S->content;break;case 306:if($i21!==null)$i21.=(float)$S->content;else $i21=(float)$S->content;break;case 16391:if($i21!==null)$i21.=null;else $i21=null;break;case 384:$i26="";$i27=prev($g);if($i27&&$i27->b==307){$i26=$i27->content.$S->content;end($i8);unset($i8[key($i8)]);next($g);}while($i28=next($g)){if($i28->b!=384&&$i28->b!=307&&$i28->b!=380)break;$i26.=$i28->content;$i20[]=$i28;}if(ConstantContainer::isDefined($i26))if($i21!==null)$i21.=ConstantContainer::getConstant($i26);else $i21=ConstantContainer::getConstant($i26);else $i21.=$i26;break;case 370:if($i21!==null)$i21.=$this->inlineExecute($S);else $i21=$this->inlineExecute($S);break;case 16388:goto parseArg;default:if($i21!==null)$i21.=$S->content;else $i21=$S->content;}if(isset($i17))continue;parseArg:if(!isset($i15[$i18+$i19])||!$i15[$i18+$i19]){$i8[]=$i21;}else if($i15[$i18+$i19]=='?'){$i19++;goto parseArg;}else {switch(strtolower($i15[$i18+$i19])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i15[$i18+$i19],$i13);case'n':if(is_numeric($i21)&&is_string($i21))$i8[]=(float)$i21;else if(is_int($i21)||is_float($i21)||$i21===null)$i8[]=$i21;else throw new InstructionProcessorException('Illegal argument '.($i18+1).' for '.$W.': '.gettype($i21).' '.(string)$i21.' given, number expected',$i13);break;case's':if(is_string($i21)||$i21===null)$i8[]=$i21;else throw new InstructionProcessorException('Illegal argument '.($i18+1).' for '.$W.': '.gettype($i21).' '.(string)$i21.' given, string expected',$i13);break;case'b':if(is_bool($i21)||$i21===null)$i8[]=$i21;else throw new InstructionProcessorException('Illegal argument '.($i18+1).' for '.$W.': '.gettype($i21).' '.(string)$i21.' given, bool expected',$i13);break;case'x':$i8[]=$i21;}}$i21=null;$i18++;if(isset($i22))break;}if($i21!==null){$i22=true;goto parseArgs;}if((strpos($i14,'?')!==false&&$i18<strpos($i14,'?'))||($i18<count($i15)&&strpos($i14,'?')===false))throw new InstructionProcessorException($W.' expects '.count($i15).' arguments, '.$i18.' given',$i13);return$i13->f=$i8;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  DocCommentHandler implements TokenHandler {private static$i5=null;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(371,$this);}public function execute(Token$S,TokenVM$Y){if(Configuration::get('deletecomments',false))return 4|1|512;return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  EOFDeleter implements TokenHandler {private static$i5=null;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(16397,$this);}public function execute(Token$S,TokenVM$Y){return 512|1;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;class  OpenTagHandler implements TokenHandler {private static$i5=null;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(372,$this);}public function execute(Token$S,TokenVM$Y){if($S->content=='<?'||$S->content=='<%')$S->content='<?php ';return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  VariableHandler implements TokenHandler {private static$i5=null;private static$g=array(309,359);private$i29=array();private$i30="A";private$i31=false;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){Configuration::registerCallback('compressvariables',false,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i31){$this->i31=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i31){$this->i31=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){static$i32=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(!in_array($S->content,$i32)){if($S->b==359){if(!Configuration::get('compressproperties',false))return 4|1;$q=$Y->getTokenArray();$i33=current($q);if($i33->b!=307)goto end;while($i34=next($q)){if($i34->b==375)continue;if($i34->b==16386)goto end;break;}$i35=$i33;$i35->content='$'.$i35->content;}else $i35=$S;if(!isset($this->i29[$i35->content])){if(!Configuration::get('compressproperties',false)){$q=$Y->getTokenArray();prev($q);while($i34=prev($q)){switch($i34->b){case 348:$i36=true;goto map;default:if(!isset($i36)&&isset($i37))goto end;goto map;case 343:case 344:case 345:$i37=true;case 375:case 16392:continue 2;}}}map:do{$this->mapVariable($i35->content,is_int($this->i30)?'$i'.$this->i30:'$'.$this->i30);if($this->i30==="Z")$this->i30="a";else if($this->i30==="z")$this->i30=0;else if(is_int($this->i30))$this->i30++;else $this->i30=chr(ord($this->i30)+1);}while(count(array_keys($this->i29,$this->i29[$i35->content]))>1);}$i35->content=isset($i33)?substr($this->i29[$i35->content],1):$this->i29[$i35->content];}end:return 4|1;}public function mapVariable($i38,$i39){return$this->i29[$i38]=$i39;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Configuration;use Moody\Token;class  WhitespaceHandler implements TokenHandler {private static$i5=null;private$i31=false;private static$g=array(375,316,309,333,303,381,335,299,288,341,307,354,357,343,344,345,346,348,334,336,329,376,16393,377,331,332,340,339,356,355,358);public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){Configuration::registerCallback('deletewhitespaces',false,array($this,'invoke'));}}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i31){$this->i31=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i31){$this->i31=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){switch($S->b){case 375:$q=$Y->getTokenArray();if(($i34=current($q))&&$i34->b==377)$this->insertForcedWhitespace($Y,true);return 4|1|512;case 316:case 336:case 343:case 344:case 345:case 348:case 346:case 329:case 332:case 331:case 339:$q=$Y->getTokenArray();if($i34=current($q)){if($i34->b!=375)return 4|1;else if(($i34=next($q))&&$i34->b!=315&&$i34->b!=309)$this->insertForcedWhitespace($Y);}break;case 309:$q=$Y->getTokenArray();if($i34=current($q)){if($i34->b!=375)return 4|1;else if(($i34=next($q))&&($i34->b==326||$i34->b==288))$this->insertForcedWhitespace($Y);}break;case 333:case 381:case 335:case 299:case 288:case 341:case 354:case 357:case 334:case 376:case 340:case 356:case 355:case 358:$this->insertForcedWhitespace($Y);break;case 303:$q=$Y->getTokenArray();if($i34=current($q)){if($i34->b!=375)return 4|1;else if(($i34=next($q))&&$i34->b!=379)$this->insertForcedWhitespace($Y);}break;case 307:$q=$Y->getTokenArray();if($i34=current($q)){if($i34->b!=375)return 4|1;else if(($i34=next($q))&&($i34->b==357||$i34->b==341||$i34->b==288||$i34->b==326||$i34->b==358))$this->insertForcedWhitespace($Y);}break;case 16393:$q=$Y->getTokenArray();prev($q);$i34=prev($q);if($i34->b==377)$this->insertForcedWhitespace($Y,true);break;case 377:$q=$Y->getTokenArray();if(($i34=current($q))&&$i34->b!=16393)$this->insertForcedWhitespace($Y,true);break;}end:return 4|1;}private function insertForcedWhitespace(TokenVM$Y,$i40=false){$S=new Token;$S->content=$i40?"\r\n":" ";$S->b=16392;$S->d="Moody WhitespaceHandler";$Y->insertTokenArray(array($S));}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ClassEntry {public$i41=array();public$M="";public$i42="";public$P=null;public$J=array();}class  ClassFetcher implements TokenHandler {private static$i5=null;private$i43=null;private$i44=array();public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(354,$this);}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i45=354;$N=new ClassEntry;while($i46=next($q)){switch($i46->b){case 358:$i45=358;break;case 357:$i45=357;break;case 307:switch($i45){case 354:$i47=strtolower($i46->content);if($O=NamespaceFetcher::getInstance()->getCurrentNamespace())$N->M=$O."\\".$i47;else $N->M=$i47;$N->i42=$i47;break;case 357:$N->P=$this->fetchClass(strtolower($i46->content));break;case 358:$N->i41[]=strtolower($i46->content);}break;case 16395:break 2;}}$this->i43=$this->i44[$N->M]=$N;$i48=ScopeFetcher::getInstance();$i48->addLeaveCallback(array($this,'leaveClass'),$i48->getDepth()+1);$Y->jump($i46);return 1024|4|1;}public function getCurrentClass(){return$this->i43;}public function leaveClass(){$this->i43=null;}public function fetchClass($M){$M=strtolower($M);switch($M){case"self":return$this->i43;case"parent":return$this->i43?$this->i43->P:null;default:return isset($this->i44[$M])?$this->i44[$M]:null;}}public function registerClass($M,ClassEntry$i49){$this->i44[$M]=$i49;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\ConstantContainer;class  ConstantDefinitionHandler implements TokenHandler {private static$i5=null;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(335,$this);}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i50=false;$N=ClassFetcher::getInstance()->getCurrentClass();while($i46=next($q)){switch($i46->b){case 16393:break 2;case 16394:$i50=true;case 375:continue 2;case 307:if($i50){if(ConstantContainer::isDefined($i46->content)){ConstantContainer::define($M,ConstantContainer::getConstant($i46->content),$N,true);}else {ConstantContainer::define($M,$i46->content,$N,true);}}else {$M=$i46->content;}break;case 305:ConstantContainer::define($M,(int)$i46->content,$N,true);break;case 306:ConstantContainer::define($M,(float)$i46->content,$N,true);break;case 16389:ConstantContainer::define($M,true,$N,true);break;case 16390:ConstantContainer::define($M,false,$N,true);break;case 315:ConstantContainer::define($M,eval('return ('.$i46->content.');'),$N,true);break;case 16388:$i50=false;}}$Y->jump($i46);return 1024|4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  NamespaceFetcher implements TokenHandler {private static$i5=null;private$i51=array("");public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(381,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==381){$q=$Y->getTokenArray();$O="";for($S=current($q);;$S=next($q)){switch($S->b){case 384:if($O)$O.="\\";break;case 307:$O.=strtolower($S->content);break;case 16393:$Y->registerTokenHandler(16397,$this);break 2;case 16395:$i48=ScopeFetcher::getInstance();$i48->addLeaveCallback(array($this,'leaveNamespace'),$i48->getDepth()+1);break 2;}}$this->i51[]=$O;$Y->jump($S);return 1024|4|1;}else {$this->leaveNamespace();if(count($this->i51)==1)$Y->unregisterTokenHandler(16397,$this);return 512|1;}}public function leaveNamespace(){end($this->i51);unset($this->i51[key($this->i51)]);}public function getCurrentNamespace(){return end($this->i51);}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ScopeFetcher implements TokenHandler {private static$i5=null;private$i52=0;private$i53=array();private$i54=array();public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(16395,$this);TokenVM::globalRegisterTokenHandler(16396,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==16395){$this->i52++;if(isset($this->i53[$this->i52])){foreach($this->i53[$this->i52]as$a=>$H){call_user_func($H,$this->i52);unset($this->i53[$a]);}}}else {if(isset($this->i54[$this->i52])){foreach($this->i54[$this->i52]as$a=>$H){call_user_func($H,$this->i52);unset($this->i54[$a]);}}$this->i52--;}return 4|1;}public function addEnterCallback($H,$i52){$this->i53[$i52][]=$H;}public function addLeaveCallback($H,$i52){$this->i54[$i52][]=$H;}public function getDepth(){return$this->i52;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;use Moody\ConstantContainer;use Moody\Configuration;use Moody\InstructionHandlers\Macro;use Moody\TokenHandlers\InstructionProcessor;class  SymbolSubstitutionHandler implements TokenHandler {private static$i5=null;private static$g=array(307,384,16398,16399);private$i31=false;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){Configuration::registerCallback('autosubstitutesymbols',true,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i31){$this->i31=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i31){$this->i31=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i55=0;$i56=$S;switch($S->b){case 16398:case 16399:$N=ClassFetcher::getInstance()->getCurrentClass();if($S->b==16399)$N=$N->P;for($i46=current($q);;$i46=next($q)){if($i46->b==380)continue;if($i46->b!=307)break 2;if(ConstantContainer::isDefined($i46->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i46->content,$N))){$S->content=Token::makeEvaluatable($L);$Y->jump(next($q));return 64|1;}break 2;}break;case 384:$S=current($q);next($q);case 307:$i57=$S->content;if($i58=Macro::getMacro(strtolower($i57))){$i9="";if($i58->numArgs()){$i59=0;for($i46=current($q);;$i46=next($q)){switch($i46->b){case 16386:$i59++;if($i59>1)$i9.=$i46->content;break;case 16387:if(!(--$i59))break 2;default:$i9.=$i46->content;}}$Y->moveTo(next($q));}InstructionProcessor::getInstance()->callInstruction($i58->M,$Y,0,array(),$i9);return 512|1;}for($i46=current($q);;$i46=next($q)){switch($i46->b){case 380:$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if(!$O||!($N=ClassFetcher::getInstance()->fetchClass($O."\\".$i57)))$N=ClassFetcher::getInstance()->fetchClass($i57);continue 2;case 307:if(isset($N)&&ConstantContainer::isDefined($i46->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i46->content,$N))){$i56->content=Token::makeEvaluatable($L);$Y->jump(next($q));return 64|1;}else {$i57.=$i46->content;continue 2;}case 384:$i57.="\\";continue 2;default:break 2;}}if(ConstantContainer::isDefined($i57)&&is_scalar($L=ConstantContainer::getConstant($i57))){$i56->content=Token::makeEvaluatable($L);$Y->jump($i46);return 1|64;}break;}return 1|4;}}}namespace  Moody\TokenHandlers {use Moody\ConstantContainer;use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  UseStatementParser implements TokenHandler {private static$i5=null;public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}private function __construct(){TokenVM::globalRegisterTokenHandler(340,$this);}public function execute(Token$S,TokenVM$Y){$i60=ClassFetcher::getInstance();if($i60->getCurrentClass())return 4|1;$q=$Y->getTokenArray();$i45=340;$i61="";$i62="";for($i46=current($q);;$i46=next($q)){switch($i46->b){case 326:$i45=326;break;case 384:if($i45==326){if($i62)$i62.="\\";}else if($i61){$i61.="\\";}break;case 307:if($i45==326)$i62.=$i46->content;else $i61.=$i46->content;break;case 16388:case 16393:if(!($N=$i60->fetchClass($i61)))break 2;if($i45==340){$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O)$i62=$O."\\".$N->i42;else $i62=$N->i42;}$i60->registerClass(strtolower($i62),$N);if($i46->b==16388){$i62=$i61="";break;}break 2;}}$Y->jump($i46);return 1024|1;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  BooleanCastHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'x');if($Z&1)return (bool)$i8[0];$S->content=Token::makeEvaluatable((bool)$i8[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  CallHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i63=substr($W,0,1)=='.'?substr($W,1):$W;$i8=$X->parseArguments($S,$W,'');$i8=array_merge(array($i63),$i8);}else {$i8=$X->parseArguments($S,$W,'s');$i63=$i8[0];}if(strpos($i63,'::')){$i64=explode('::',$i63,2);$i63=array($i64[0],$i64[1]);if(!method_exists($i64[0],$i64[1]))throw new InstructionProcessorException($i8[0].'() does not exist',$S);}else if(!function_exists($i63))throw new InstructionProcessorException($i8[0].'() does not exist',$S);if(!is_callable($i63))throw new InstructionProcessorException($i8[0].'() is not callable from the current scope',$S);$i65=$i8;unset($i65[0]);$E=call_user_func_array($i63,$i65);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if(substr($W,0,1)=='.')$W=substr($W,1);if(strpos($W,'::')){$i64=explode('::',$W,2);if(!method_exists($i64[0],$i64[1]))return false;}else if(!function_exists($W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ConfigurationHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'s?x');if(!isset($i8[1])){if($Z&1)return Configuration::get($i8[0],null);$S->content=Token::makeEvaluatable(Configuration::get($i8[0],null));return 0;}else Configuration::set($i8[0],$i8[1],$Y);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GetConstantHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2)$i8=array(substr($W,0,1)=='.'?substr($W,1):$W);else $i8=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i8[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i8[0],$S);$i66=ConstantContainer::getConstant($i8[0]);if($Z&1)return$i66;$S->content=Token::makeEvaluatable($i66);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if($X->parseArguments($S,$W,''))return false;if(!ConstantContainer::isDefined(substr($W,0,1)=='.'?substr($W,1):$W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\ConstantContainer;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;class  DefineHandler implements InstructionHandler, DefaultInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i8=$X->parseArguments($S,$W,'sx');$K=substr($W,0,1)=='.'?substr($W,1):$W;$i67=array('(',')','+','-','*','/','|','&','^','>>','<<');$i68="";foreach($i8 as$i69=>$i70){if(!$i69)continue;if(!is_int($i70)&&!in_array($i70,$i67))$i71=false;$i68.=$i70;}if(isset($i71))$E=$i68;else if(($E=eval('return ('.$i68.');'))===false)throw new InstructionProcessorException('Math syntax error');switch($i8[0]){case'=':ConstantContainer::define($K,$E);break;case'.=':ConstantContainer::define($K,ConstantContainer::getConstant($K).$E);break;case'+=':ConstantContainer::define($K,ConstantContainer::getConstant($K)+$E);break;case'-=':ConstantContainer::define($K,ConstantContainer::getConstant($K)-$E);break;case'*=':ConstantContainer::define($K,ConstantContainer::getConstant($K)*$E);break;case'/=':ConstantContainer::define($K,ConstantContainer::getConstant($K)/$E);break;case'|=':ConstantContainer::define($K,ConstantContainer::getConstant($K)|$E);break;case'^=':ConstantContainer::define($K,ConstantContainer::getConstant($K)^$E);break;case'&=':ConstantContainer::define($K,ConstantContainer::getConstant($K)&$E);break;case'>>=':ConstantContainer::define($K,ConstantContainer::getConstant($K)>>$E);break;case'<<=':ConstantContainer::define($K,ConstantContainer::getConstant($K)<<$E);break;}}else {$i8=$X->parseArguments($S,$W,'sx');ConstantContainer::define($i8[0],$i8[1]);}return 512;}public function canExecute(Token$S,$W,InstructionProcessor$X){$i8=$X->parseArguments($S,$W,'');$i67=array('=','.=','+=','-=','*=','/=','|=','&=','^=','<<=','>>=');if(in_array($i8[0],$i67)&&!($i8[0]!='='&&!ConstantContainer::isDefined(substr($W,0,1)=='.'?substr($W,1):$W)))return true;return false;}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\ClassFetcher;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\TokenHandlers\ClassEntry;class  DumpClassEntryHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('dumpclassentry',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'?s');if($i8){$N=ClassFetcher::getInstance()->fetchClass($i8[0]);}else {$N=ClassFetcher::getInstance()->getCurrentClass();}if(!$N)throw new InstructionProcessorException('Unknown class specified',$S);$this->dumpClassEntry($N,"");}private function dumpClassEntry(ClassEntry$N,$i72){echo"Moody Class Entry ".$N->M." {".'
';if($N->P){echo$i72."Extends ";$this->dumpClassEntry($N->P,$i72."\t");}if($N->i41){echo$i72."Implements {".'
';foreach($N->i41 as$i73){echo$i72."\t".$i73.'
';}echo$i72."}".'
';}if($N->J){foreach($N->J as$M=>$E){echo$i72.$M." = ".$E.'
';}}echo$i72."}".'
';}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EchoHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'x');foreach($i8 as$i70)echo (string)$i70;return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getToken()==$S){if(!($i12->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i74=$i12;}}foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getEndToken()==$S){if($i12->getEndTokenAction()==1){$i74->setEndTokenAction(1);$Y->jump($i74->getEndToken());return 512|64;}}}return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseIfHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getToken()==$S){if(!($i12->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i74=$i12;}}foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getEndToken()==$S){if($i12->getEndTokenAction()==1){$i74->setEndTokenAction(1);$Y->jump($i74->getEndToken());return 512|64;}}}return IfHandler::getInstance()->execute($S,$W,$X,$Y);}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  EndLongDefineHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endlongdefine',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\InstructionProcessor;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenVM;use Moody\MultiTokenInstruction;class  EndIfHandler implements InstructionHandlerWithRegister {private static$i5;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EvalHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'s?bb');if(!isset($i8[1])||$i8[1]===true){if(!strpos($i8[0],'<?')){$i75=true;$q=Token::tokenize('<?php '.$i8[0].' ?>',$W.' code');}else $q=Token::tokenize($i8[0],$W.' code');$Y=new TokenVM();$q=$Y->execute($q);if(isset($i75)){reset($q);unset($q[key($q)]);end($q);unset($q[key($q)]);}$i8[0]="";foreach($q as$i76){$i8[0].=$i76->content;}}$i77=eval($i8[0]);if($i77!==null){if($Z&1)return$i77;$S->content=!isset($i8[2])||$i8[2]===true?Token::makeEvaluatable($i77):$i77;return 0;}return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ExitHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 2|512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GotoHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');$i78=LabelHandler::getLabel($i8[0]);if(!($i78 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i8[0],$S);$Y->jump($i78);return 64|512;}}}namespace  Moody\InstructionHandlers {use Moody\END_TOKEN_ELSE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'x');foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getToken()==$S){if(!($i12->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i79="";$i77=false;foreach($i8 as$i70){if(is_string($i70)&&strlen($i70)&&strtolower($i70)!=="true"&&strtolower($i70)!=="false"){$g=Token::tokenize('<?php '.$i70.' ?>');if($g[1]->b==307)$i70=Token::makeEvaluatable($i70);}else if(is_string($i70)&&!strlen($i70))$i70="''";if($i70===true)$i70="true";else if($i70===false)$i70="false";else if($i70===null)$i70="null";$i79.=$i70;}$i77=eval('return (int) (bool) ('.$i79.');');if($i77===1){$i12->setEndTokenAction(1);return 512;}if($i77===false)throw new InstructionProcessorException('If-condition '.$i79.' is invalid',$S);$i12->setEndTokenAction(2);$Y->jump($i12->getEndToken());return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfDefHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getToken()==$S){if(!($i12->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(ConstantContainer::isDefined($i8[0])){$i12->setEndTokenAction(1);return 512;}$Y->jump($i12->getEndToken());$i12->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfNotDefHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$i12){if($i12->getToken()==$S){if(!($i12->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(!ConstantContainer::isDefined($i8[0])){$i12->setEndTokenAction(1);return 512;}$Y->jump($i12->getEndToken());$i12->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IncludeHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');if(!file_exists($i8[0]))throw new InstructionProcessorException($i8[0].' does not exist',$S);if(!is_readable($i8[0]))throw new InstructionProcessorException($i8[0].' is not readable - Make sure Moody has the rights to read it',$S);$j=file_get_contents($i8[0]);$g=Token::tokenize($j,$i8[0]);switch($g[0]->b){case 372:unset($g[0]);break;case 311:$S=new Token;$S->b=374;$S->content=" ?>";$i80=array($S);foreach($g as$S)$i80[]=$S;$g=$i80;}switch(end($g)->b){case 374:unset($g[key($g)]);break;case 311:$S=new Token;$S->b=372;$S->content="<?php ";$g[]=$S;}$S=new Token;$S->b=16397;$S->content=$i8[0];$g[]=$S;$Y->insertTokenArray($g);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  InputHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('input',$this);InstructionProcessor::getInstance()->registerHandler('getinput',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'?n');if(!defined('STDIN')||!is_resource(\STDIN))throw new InstructionProcessorException('No input stream available',$S);$E=fread(\STDIN,isset($i8[0])?$i8[0]:1024);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IsDefinedHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'s');if(ConstantContainer::isDefined($i8[0])){if($Z&1)return true;$S->content=Token::makeEvaluatable(true);}else {if($Z&1)return false;$S->content=Token::makeEvaluatable(false);}return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  LabelHandler implements InstructionHandlerWithRegister {private static$i5=null;private static$i81=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');if(isset(self::$i81[$i8[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i8[0].'" (first definition at '.self::$i81[$i8[0]]->d.':'.self::$i81[$i8[0]]->e,$S);self::$i81[$i8[0]]=$S;}public static function getLabel($M){if(isset(self::$i81[$M]))return self::$i81[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  LongDefineHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('longdefine',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('longDefine')as$i12){if($i12->getToken()==$S){$T=$i12->getEndToken();if(!($T instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endLongDefine?',$S);$g=$Y->getTokenArray();$i82="";while($S=current($g)){if($S==$T){ConstantContainer::define($i8[0],$i82);$Y->jump($S);return 64|512;}$i82.=$S->content;next($g);}}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  MacroHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if(strtolower($W)=='.macro'){if($Z&1)throw new InstructionProcessorException($W.' does not support inline execution',$S);$i8=$X->parseArguments($S,$W,'ss');if(!strlen($i8[0]))throw new InstructionProcessorException('Macro name cannot be empty',$S);$i8[0]=strtolower($i8[0]);$i58=new Macro($i8[0],$i8[1]);$X->registerHandler($i8[0],$this);unset($i8[0],$i8[1]);foreach($i8 as$i70)$i58->addArgument($i70);return 512;}$i83=substr(strtolower($W),1);$i58=Macro::getMacro($i83);if(!$i58)throw new InstructionProcessorException('Call to bad macro',$S);$i15="";for($i84=0;$i84<$i58->numArgs();$i84++)$i15.='x';$i8=$X->parseArguments($S,$W,$i15);if($Z&1){$code="";foreach($i58->buildCode($i8)as$S)$code.=$S->content;return$code;}else $Y->insertTokenArray($i58->buildCode($i8));return 512;}}class  Macro {public$M="";private$code="";private$i85=array();private static$i86=array();public function __construct($M,$code){$this->M=$M;$this->code=$code;self::$i86[$M]=$this;}public function addArgument($i87){$this->i85[]=$i87;}public function numArgs(){return count($this->i85);}public function buildCode($i8=array()){$i84=0;$code=$this->code;foreach($this->i85 as$i70){$code=str_replace($i70,$i8[$i84],$code);$i84++;}$g=Token::tokenize('<?php '.$code,'Macro '.$this->M);unset($g[0]);return$g;}public static function getMacro($M){if(isset(self::$i86[$M]))return self::$i86[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenHandlers\VariableHandler;use Moody\TokenVM;class  MapVariableHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$S);VariableHandler::getInstance()->mapVariable($i8[0],$i8[1]);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  NumberCastHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'x');if($Z&1)return (float)$i8[0];$S->content=Token::makeEvaluatable((float)$i8[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RaiseErrorHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'s');throw new InstructionProcessorException($i8[0],$S);}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RegisterConfigurationHandler implements InstructionHandlerWithRegister {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('registerconfiguration',$this);InstructionProcessor::getInstance()->registerHandler('registerconfig',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'sx');Configuration::set($i8[0],$i8[1]);}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  StringCastHandler implements InlineInstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i8=$X->parseArguments($S,$W,'x');if($Z&1)return (string)$i8[0];$S->content=Token::makeEvaluatable((string)$i8[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  UndefineHandler implements InstructionHandler {private static$i5=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$i5)self::$i5=new self;return self::$i5;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i8=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i8[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i8[0],$S);ConstantContainer::undefine($i8[0]);return 512;}}}?>