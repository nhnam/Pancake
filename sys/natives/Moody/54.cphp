<?php namespace  Moody {class  Configuration {private static$A=array();private static$B=array();public static function load($C){}public static function set($D,$E,TokenVM$F=null){$D=strtolower($D);if(isset(self::$B[$D])){call_user_func(self::$B[$D],$E,$F);}return self::$A[$D]=$E;}public static function get($D,$G=null){$D=strtolower($D);if(isset(self::$A[$D]))return self::$A[$D];return$G;}public static function registerCallback($D,$G,$H,$I=true){if(!is_callable($H)){throw new MoodyException('Bad configuration callback');}$D=strtolower($D);self::$B[$D]=$H;if($I){$H(isset(self::$A[$D])?self::$A[$D]:$G);}}}}namespace  Moody {use Moody\TokenHandlers\ClassEntry;use Moody\TokenHandlers\ClassFetcher;use Moody\TokenHandlers\NamespaceFetcher;class  ConstantContainer {private static$J=array();public static function initialize(){foreach(get_defined_constants()as$K=>$L)if(!self::isDefined($K))self::define($K,$L);}public static function getConstant($M,ClassEntry$N=null){$M=strtolower($M);if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return$N->J[$M[1]];}while($N=$N->P);}return;}if($N){do{if(isset($N->J[$M]))return$N->J[$M];}while($N=$N->P);return;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return self::$J[$O."\\".$M];if(isset(self::$J[$M]))return self::$J[$M];}public static function isDefined($M,ClassEntry$N=null){$M=strtolower($M);if($N){do{if(isset($N->J[$M]))return true;}while($N=$N->P);return false;}if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return true;}while($N=$N->P);}return false;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return true;return isset(self::$J[$M]);}public static function define($M,$E,ClassEntry$N=null,$O=false){if($N){$N->J[strtolower($M)]=$E;}else {if($O&&$O=NamespaceFetcher::getInstance()->getCurrentNamespace())$M=$O."\\".strtolower($M);else $M=strtolower($M);self::$J[$M]=$E;}}public static function undefine($M){$M=strtolower($M);if(isset(self::$J[$M]))unset(self::$J[$M]);}}}namespace  Moody {const  END_TOKEN_NO_EXECUTE = 1;const  END_TOKEN_EXECUTE = 2;class  MultiTokenInstruction {private static$Q=array();private static$R=array();private$S;private$T;private$U=2;public function __construct(Token$S,$N){self::$Q[$N][]=$this;self::$R[$N][]=$this;$this->S=$S;}public static function setEndToken(Token$S,$N){if(!isset(self::$R[$N])||!self::$R[$N])throw new InstructionProcessorException('End token of type '.$N.' while not active',$S);end(self::$R[$N]);self::$R[$N][key(self::$R[$N])]->T=$S;unset(self::$R[$N][key(self::$R[$N])]);}public function getToken(){return$this->S;}public function getEndToken(){return$this->T;}public function setEndTokenAction($V){$this->U=$V;}public function getEndTokenAction(){return$this->U;}public static function getAll($N){return self::$Q[$N];}}}namespace  Moody {interface InstructionHandler{public static function getInstance();public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InlineInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);}interface DefaultInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);public function canExecute(Token$S,$W,TokenHandlers\InstructionProcessor$X);}}namespace  Moody {class  InstructionProcessorException extends \Exception {private$S;public function __construct($message,Token$S){$this->message=$message;$this->S=$S;}public function __toString(){$C='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString()."\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;return$C;}}}namespace  Moody {class  MoodyException extends \Exception {public function __toString(){$C='Moody encountered an unexpected error and can not continue.'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace: '."\r\n".$this->getTraceAsString();return$C;}}}namespace  Moody {define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);define('T_EQUAL',16394);define('T_CURLY_BRACKET_OPEN',16395);define('T_CURLY_BRACKET_CLOSE',16396);define('T_EOF',16397);define('T_SELF',16398);define('T_PARENT',16399);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class  Token {public$a=0;public$b=0;public$c=0;public$d="Unknown";public$e=0;public$content="";public$f=array();public$g=false;public$h="";private static$i=0;private static$j=0;private static$k=array(347=>"T_ABSTRACT",271=>"T_AND_EQUAL",362=>"T_ARRAY",292=>"T_ARRAY_CAST",326=>"T_AS",313=>"T_BAD_CHARACTER",279=>"T_BOOLEAN_AND",278=>"T_BOOLEAN_OR",290=>"T_BOOL_CAST",331=>"T_BREAK",329=>"T_CASE",338=>"T_CATCH",312=>"T_CHARACTER",354=>"T_CLASS",364=>"T_CLASS_C",298=>"T_CLONE",374=>"T_CLOSE_TAG",16388=>"T_COMMA",370=>"T_COMMENT",273=>"T_CONCAT_EQUAL",335=>"T_CONST",315=>"T_CONSTANT_ENCAPSED_STRING",332=>"T_CONTINUE",379=>"T_CURLY_OPEN",16395=>"T_CURLY_BRACKET_OPEN",16396=>"T_CURLY_BRACKET_CLOSE",296=>"T_DEC",324=>"T_DECLARE",330=>"T_DEFAULT",383=>"T_DIR",274=>"T_DIV_EQUAL",306=>"T_DNUMBER",317=>"T_DO",371=>"T_DOC_COMMENT",378=>"T_DOLLAR_OPEN_CURLY_BRACES",16384=>"T_DOT",360=>"T_DOUBLE_ARROW",294=>"T_DOUBLE_CAST",380=>"T_DOUBLE_COLON",316=>"T_ECHO",303=>"T_ELSE",302=>"T_ELSEIF",352=>"T_EMPTY",314=>"T_ENCAPSED_AND_WHITESPACE",325=>"T_ENDDECLARE",321=>"T_ENDFOR",323=>"T_ENDFOREACH",304=>"T_ENDIF",328=>"T_ENDSWITCH",319=>"T_ENDWHILE",377=>"T_END_HEREDOC",16397=>"T_EOF",16394=>"T_EQUAL",260=>"T_EVAL",300=>"T_EXIT",357=>"T_EXTENDS",16390=>"T_FALSE",369=>"T_FILE",346=>"T_FINAL",320=>"T_FOR",16392=>"T_FORCED_WHITESPACE",322=>"T_FOREACH",334=>"T_FUNCTION",367=>"T_FUNC_C",342=>"T_GLOBAL",333=>"T_GOTO",353=>"T_HALT_COMPILER",372=>"T_OPEN_TAG",16387=>"T_ROUND_BRACKET_CLOSE",16386=>"T_ROUND_BRACKET_OPEN",16393=>"T_SEMICOLON",307=>"T_STRING",16389=>"T_TRUE",16385=>"T_UNKNOWN",309=>"T_VARIABLE",375=>"T_WHITESPACE");public function __construct(){$this->a=self::$i++;}public static function tokenize($code,$l=null){$i=token_get_all($code);if(!$i)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$m=array();self::$j++;foreach($i as$S){$n=new Token;$n->c=self::$j;if($l)$n->d=$l;if(is_array($S)){$n->b=$S[0];$n->content=$S[1];$n->e=$S[2];switch(strtolower($n->content)){case'true':$n->b=16389;break;case'false':$n->b=16390;break;case'null':$n->b=16391;break;case'self':$n->b=16398;break;case'parent':$n->b=16399;break;}}else {$n->content=$S;$n->e=-1;switch($S){case'.':$n->b=16384;break;case'(':$n->b=16386;break;case')':$n->b=16387;break;case',':$n->b=16388;break;case';':$n->b=16393;break;case'=':$n->b=16394;break;case'{':$n->b=16395;break;case'}':$n->b=16396;break;default:$n->b=16385;}}$m[]=$n;}return$m;}public static function getName($o){return isset(self::$k[$o])?self::$k[$o]:$o;}public function __toString(){$C='Type: '.self::getName($this->b)."\r\n";$C.='Content: '.$this->content."\r\n";if($this->d!="Unknown"){$C.='Origin: '.$this->d."\r\n";$C.='Line: '.$this->e."\r\n";}return$C;}public static function makeEvaluatable($E){if(is_string($E))return"'".str_replace("'","\'",$E)."'";if(is_int($E)||is_float($E))return$E;if($E===true)return"true";if($E===false)return"false";if($E===null)return"null";}}}namespace  Moody {interface TokenHandler{public static function getInstance();public function execute(Token$S,TokenVM$Y);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$S,TokenVM$Y);}}namespace  Moody {const  MOODY_VERSION = "1.0";class  TokenVM {const  NEXT_TOKEN = 1;const  QUIT = 2;const  NEXT_HANDLER = 4;const  ERROR = 8;const  REEXECUTE_TOKEN = 16;const  REEXECUTE_HANDLER = 32;const  JUMP = 64;const  CLEAR_RETVAL = 128;const  CLEAR_ERROR = 256;const  DELETE_TOKEN = 512;const  JUMP_WITHOUT_DELETE_TOKEN = 1024;private static$p=array();private$q=array();private$r=array();private$s=null;public function __construct(){$this->q=self::$p;}public function execute($r){if(!$r)throw new VMException('Virtual machine received empty token array');$this->r=$r;foreach($this->r as$S){if(isset($this->q[$S->b])){foreach($this->q[$S->b]as$t){if(is_callable(array($t,'register'))){$t->register($S,$this);}}reset($this->q[$S->b]);}}reset($this->r);$u=array();nextToken:if(!($S=current($this->r)))goto quit;$v=$S->a;next($this->r);executeToken:$w=0;nextHandler:if(isset($this->q[$S->b])){$t=current($this->q[$S->b]);next($this->q[$S->b]);}else {$u[]=$S;goto nextToken;}executeHandler:$x=$t->execute($S,$this);if($x&128)$w=$x;else $w|=$x;doRetval:if($w&32){$w^=32;goto executeHandler;}if($w&4){$w^=4;if(current($this->q[$S->b])!==false)goto nextHandler;}if($w&16){reset($this->q[$S->b]);$w^=16;goto executeToken;}if(!($w&512))$u[]=$S;if($w&2)goto quit;if($w&8&&!($w&256))throw new VMException('Token handler returned an error',$S);if(($w&64)||($w&1024)){if(!($this->s instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$S);if(!in_array($this->s,$this->r))throw new VMException('Cannot jump to new token as it is not specified in current token array',$S);$y=array_search($this->s,$this->r);if($y<key($this->r)){while(prev($this->r)!=$this->s);}else if($y>key($this->r)){if($w&1024){$u[]=current($this->r);while(($z=next($this->r))!=$this->s){$u[]=$z;}}else {while(next($this->r)!=$this->s);}}}if($w&1){reset($this->q[$S->b]);goto nextToken;}throw new VMException('Token handler did not specify an action for the virtual machine',$S);quit:return$u;}public static function globalRegisterTokenHandler($o,TokenHandler$i0){if(!($i0 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($o).' is invalid');if(!isset(self::$p[$o]))self::$p[$o]=array($i0);else self::$p[$o][]=$i0;}public static function globalUnregisterTokenHandler($o,TokenHandler$i0){if(!isset(self::$p[$o])||($y=array_search($i0,self::$p[$o]))===false)return;unset(self::$p[$o][$y]);if(!self::$p[$o])unset(self::$p[$o]);}public function registerTokenHandler($o,TokenHandler$i0){if(!($i0 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($o).' is invalid');if(!isset($this->q[$o]))$this->q[$o]=array($i0);else $this->q[$o][]=$i0;}public function unregisterTokenHandler($o,TokenHandler$i0){if(!isset($this->q[$o])||($y=array_search($i0,$this->q[$o]))===false)return;unset($this->q[$o][$y]);if(!$this->q[$o])unset($this->q[$o]);}public function jump(Token$S){$this->s=$S;}public function insertTokenArray($r){reset($r);$i1=current($r);while($S=current($this->r)){$i2[]=$S;unset($this->r[key($this->r)]);}foreach($r as$S){if(isset($this->q[$S->b])){$i3=current($this->q[$S->b]);foreach($this->q[$S->b]as$t){if(is_callable(array($t,'register'))){$t->register($S,$this);}}reset($this->q[$S->b]);if($i3!==current($this->q[$S->b])){while(next($this->q[$S->b])!==$i3);}}$this->r[]=$S;}foreach($i2 as$S)$this->r[]=$S;if(current($this->r)!==$i1){while(prev($this->r)!==$i1);}}public function getTokenArray(){return$this->r;}public function moveTo(Token$S){$y=array_search($S,$this->r);if($y<key($this->r)){while(prev($this->r)!=$S);}else if($y>key($this->r)){while(next($this->r)!=$S);}}}}namespace  Moody {class  VMException extends \Exception {private$S;public function __construct($message,Token$S=null){$this->message=$message;$this->S=$S;}public function __toString(){$C='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString();if($this->S instanceof Token){$C.="\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;}return$C;}}}namespace  Moody\TokenHandlers {use Moody\InstructionHandlerWithRegister;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\TokenHandlerWithRegister;use Moody\TokenVM;use Moody\Token;use Moody\InstructionProcessorException;use Moody\Configuration;use Moody\ConstantContainer;use Moody\InstructionHandler;class  InstructionProcessor implements TokenHandlerWithRegister {private static$i4=null;private$q=array();private$i5=array();const  EXECUTE_TYPE_INLINE = 1;const  EXECUTE_TYPE_DEFAULT = 2;public static function getInstance(){if(!self::$i4)new self;return self::$i4;}private function __construct(){self::$i4=$this;TokenVM::globalRegisterTokenHandler(370,$this);foreach(get_declared_classes()as$N){if(in_array('Moody\InstructionHandler',class_implements($N)))$N::getInstance();}}public function callInstruction($W,TokenVM$Y,$i6=0,$i7=array(),$i8=""){$S=new Token;$S->b=370;$S->h=$W;if($i8)$S->content="#".$W." ".$i8;$S->d="Moody Instruction Processor Direct Call";$S->f=$i7;return$i6==1?$this->inlineExecute($S):$this->execute($S,$Y);}public function execute(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();$i10=0;if($S->h||preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){if(!$S->h){$S->h=strtolower($i9[1]);if(substr($S->h,0,1)=='.')$S->h=substr($S->h,1);}if(isset($this->q[$S->h])){$i10=$this->q[$S->h]->execute($S,$S->h,$this,$Y);if($S->g)$S->f=array();goto end;}else if($this->i5){foreach($this->i5 as$i0){if($i0->canExecute($S,$S->h,$this)){$i10=$i0->execute($S,$S->h,$this,$Y,2);if($S->g)$S->f=array();goto end;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$S->h.'"',$S);}else if(Configuration::get('deletecomments',true))$i10=512;end:return (4|1)^$i10;}public function register(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();if($S->h||preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){if(!$S->h){$S->h=strtolower($i9[1]);if(substr($S->h,0,1)=='.')$S->h=substr($S->h,1);}if(isset($this->q[$S->h])&&$this->q[$S->h]instanceof InstructionHandlerWithRegister){$this->q[$S->h]->register($S,$S->h,$this,$Y);if($S->g)$S->f=array();}}}private function inlineExecute(Token$S){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();if($S->h||preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){if(!$S->h){$S->h=strtolower($i9[1]);if(substr($S->h,0,1)=='.')$S->h=substr($S->h,1);}if(isset($this->q[$S->h])){if(!($this->q[$S->h]instanceof InlineInstructionHandler))throw new InstructionProcessorException($S->h.' does not support inline execution',$S);$w=$this->q[$S->h]->execute($S,$S->h,$this,null,1);if($S->g)$S->f=array();return$w;}else if($this->i5){foreach($this->i5 as$i0){if(!($i0 instanceof InlineInstructionHandler))continue;if($i0->canExecute($S,$S->h,$this)){$w=$i0->execute($S,$S->h,$this,null,2|1);if($S->g)$S->f=array();return$w;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i9[1].'"',$S);}}public function registerHandler($h,InstructionHandler$i0){if(!($i0 instanceof InstructionHandler))throw new InstructionProcessorException('Handler for instruction "'.$h.'" is invalid');$this->q[$h]=$i0;}public function registerDefaultHandler(DefaultInstructionHandler$i0){if(!($i0 instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default handler '.get_class($i0).' is invalid');$this->i5[]=$i0;}public function parseArguments(Token$i11,$W,$i12){if($i11->f)return$i11->f;if($i12)$i13=str_split($i12);else $i13=array();if(!stripos($i11->content,$W))throw new InstructionProcessorException('Token corrupted',$i11);$i14=substr($i11->content,stripos($i11->content,$W)+strlen($W));if(strpos($i11->content,"/*")===0)$i14=substr($i14,0,strlen($i14)-2);$i=Token::tokenize('<?php '.$i14.' ?>','Moody Argument Parser');unset($i[0],$i[1]);foreach($i as$S)if($S->b==16388)$i15=true;$i16=0;$i17=0;$i7=$i18=array();$i19=null;parseArgs:foreach($i as$S){if(isset($i20))goto parseArg;if($S->b==372||$S->b==374||$S->b==16386||$S->b==16387||$S->b==375||in_array($S,$i18))continue;switch($S->b){case 307:$i11->g=true;if(($i21=current($i))&&$i21->b==380){$i22=next($i);$i23=$S->content."::".$i22->content;if(ConstantContainer::isDefined($i23)){if($i19!==null)$i19.=ConstantContainer::getConstant($i23);else $i19=ConstantContainer::getConstant($i23);$i18=array($i21,$i22);break;}}if(ConstantContainer::isDefined($S->content))if($i19!==null)$i19.=ConstantContainer::getConstant($S->content);else $i19=ConstantContainer::getConstant($S->content);else $i19.=$S->content;break;case 315:$i19.=eval('return '.$S->content.';');break;case 16389:if($i19!==null)$i19.=true;else $i19=true;break;case 16390:if($i19!==null)$i19.=false;else $i19=false;break;case 305:if($i19!==null)$i19.=(int)$S->content;else $i19=(int)$S->content;break;case 306:if($i19!==null)$i19.=(float)$S->content;else $i19=(float)$S->content;break;case 16391:if($i19!==null)$i19.=null;else $i19=null;break;case 384:$i24="";$i11->g=true;if(current($i)!=$S)while(next($i)!=$S);$i25=prev($i);if($i25&&$i25->b==307){$i24=$i25->content.$S->content;end($i7);unset($i7[key($i7)]);}next($i);while($i26=next($i)){if($i26->b!=384&&$i26->b!=307&&$i26->b!=380)break;$i24.=$i26->content;$i18[]=$i26;}if(ConstantContainer::isDefined($i24))if($i19!==null)$i19.=ConstantContainer::getConstant($i24);else $i19=ConstantContainer::getConstant($i24);else $i19.=$i24;break;case 370:$i11->g=true;if($i19!==null)$i19.=$this->inlineExecute($S);else $i19=$this->inlineExecute($S);break;case 16388:goto parseArg;default:if($i19!==null)$i19.=$S->content;else $i19=$S->content;}if(isset($i15))continue;parseArg:if(!isset($i13[$i16+$i17])||!$i13[$i16+$i17]){$i7[]=$i19;}else if($i13[$i16+$i17]=='?'){$i17++;goto parseArg;}else {switch(strtolower($i13[$i16+$i17])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i13[$i16+$i17],$i11);case'n':if(is_numeric($i19)&&is_string($i19))$i7[]=(float)$i19;else if(is_int($i19)||is_float($i19)||$i19===null)$i7[]=$i19;else throw new InstructionProcessorException('Illegal argument '.($i16+1).' for '.$W.': '.gettype($i19).' '.(string)$i19.' given, number expected',$i11);break;case's':if(is_string($i19)||$i19===null)$i7[]=$i19;else throw new InstructionProcessorException('Illegal argument '.($i16+1).' for '.$W.': '.gettype($i19).' '.(string)$i19.' given, string expected',$i11);break;case'b':if(is_bool($i19)||$i19===null)$i7[]=$i19;else throw new InstructionProcessorException('Illegal argument '.($i16+1).' for '.$W.': '.gettype($i19).' '.(string)$i19.' given, bool expected',$i11);break;case'x':$i7[]=$i19;}}$i19=null;$i16++;if(isset($i20))break;}if($i19!==null){$i20=true;goto parseArgs;}if((strpos($i12,'?')!==false&&$i16<strpos($i12,'?'))||($i16<count($i13)&&strpos($i12,'?')===false))throw new InstructionProcessorException($W.' expects '.count($i13).' arguments, '.$i16.' given',$i11);return$i11->f=$i7;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  DocCommentHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(371,$this);}public function execute(Token$S,TokenVM$Y){if(Configuration::get('deletecomments',false))return 4|1|512;return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  EOFDeleter implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(16397,$this);}public function execute(Token$S,TokenVM$Y){return 512|1;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;class  OpenTagHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(372,$this);}public function execute(Token$S,TokenVM$Y){if($S->content=='<?'||$S->content=='<%')$S->content='<?php ';return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  VariableHandler implements TokenHandler {private static$i4=null;private static$i=array(309,359);private$i27=array();private$i28="A";private$i29=false;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){Configuration::registerCallback('compressvariables',false,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i29){$this->i29=false;if($F){foreach(self::$i as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i29){$this->i29=true;if($F){foreach(self::$i as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){static$i30=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(!in_array($S->content,$i30)){if($S->b==359){if(!Configuration::get('compressproperties',false))return 4|1;$r=$Y->getTokenArray();$i31=current($r);if($i31->b!=307)goto end;while($i32=next($r)){if($i32->b==375)continue;if($i32->b==16386)goto end;break;}$i33=$i31;$i33->content='$'.$i33->content;}else $i33=$S;if(!isset($this->i27[$i33->content])){if(!Configuration::get('compressproperties',false)){$r=$Y->getTokenArray();prev($r);while($i32=prev($r)){switch($i32->b){case 348:$i34=true;goto map;default:if(!isset($i34)&&isset($i35))goto end;goto map;case 343:case 344:case 345:$i35=true;case 375:case 16392:continue 2;}}}map:do{$this->mapVariable($i33->content,is_int($this->i28)?'$i'.$this->i28:'$'.$this->i28);if($this->i28==="Z")$this->i28="a";else if($this->i28==="z")$this->i28=0;else if(is_int($this->i28))$this->i28++;else $this->i28=chr(ord($this->i28)+1);}while(count(array_keys($this->i27,$this->i27[$i33->content]))>1);}$i33->content=isset($i31)?substr($this->i27[$i33->content],1):$this->i27[$i33->content];}end:return 4|1;}public function mapVariable($i36,$i37){return$this->i27[$i36]=$i37;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Configuration;use Moody\Token;class  WhitespaceHandler implements TokenHandler {private static$i4=null;private$i29=false;private static$i=array(375,316,309,333,303,381,335,299,288,341,307,354,357,343,344,345,346,348,334,336,329,376,16393,377,331,332,340,339,356,355,358);public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){Configuration::registerCallback('deletewhitespaces',false,array($this,'invoke'));}}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i29){$this->i29=false;if($F){foreach(self::$i as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i29){$this->i29=true;if($F){foreach(self::$i as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){switch($S->b){case 375:$r=$Y->getTokenArray();if(($i32=current($r))&&$i32->b==377)$this->insertForcedWhitespace($Y,true);return 4|1|512;case 316:case 336:case 343:case 344:case 345:case 348:case 346:case 329:case 332:case 331:case 339:$r=$Y->getTokenArray();if($i32=current($r)){if($i32->b!=375)return 4|1;else if(($i32=next($r))&&$i32->b!=315&&$i32->b!=309)$this->insertForcedWhitespace($Y);}break;case 309:$r=$Y->getTokenArray();if($i32=current($r)){if($i32->b!=375)return 4|1;else if(($i32=next($r))&&($i32->b==326||$i32->b==288))$this->insertForcedWhitespace($Y);}break;case 333:case 381:case 335:case 299:case 288:case 341:case 354:case 357:case 334:case 376:case 340:case 356:case 355:case 358:$this->insertForcedWhitespace($Y);break;case 303:$r=$Y->getTokenArray();if($i32=current($r)){if($i32->b!=375)return 4|1;else if(($i32=next($r))&&$i32->b!=379)$this->insertForcedWhitespace($Y);}break;case 307:$r=$Y->getTokenArray();if($i32=current($r)){if($i32->b!=375)return 4|1;else if(($i32=next($r))&&($i32->b==357||$i32->b==341||$i32->b==288||$i32->b==326||$i32->b==358))$this->insertForcedWhitespace($Y);}break;case 16393:$r=$Y->getTokenArray();prev($r);$i32=prev($r);if($i32->b==377)$this->insertForcedWhitespace($Y,true);break;case 377:$r=$Y->getTokenArray();if(($i32=current($r))&&$i32->b!=16393)$this->insertForcedWhitespace($Y,true);break;}end:return 4|1;}private function insertForcedWhitespace(TokenVM$Y,$i38=false){$S=new Token;$S->content=$i38?"\r\n":" ";$S->b=16392;$S->d="Moody WhitespaceHandler";$Y->insertTokenArray(array($S));}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ClassEntry {public$i39=array();public$M="";public$i40="";public$P=null;public$J=array();}class  ClassFetcher implements TokenHandler {private static$i4=null;private$i41=null;private$i42=array();public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(354,$this);}public function execute(Token$S,TokenVM$Y){$r=$Y->getTokenArray();$i43=354;$N=new ClassEntry;while($i44=next($r)){switch($i44->b){case 358:$i43=358;break;case 357:$i43=357;break;case 307:switch($i43){case 354:$i45=strtolower($i44->content);if($O=NamespaceFetcher::getInstance()->getCurrentNamespace())$N->M=$O."\\".$i45;else $N->M=$i45;$N->i40=$i45;break;case 357:$N->P=$this->fetchClass(strtolower($i44->content));break;case 358:$N->i39[]=strtolower($i44->content);}break;case 16395:break 2;}}$this->i41=$this->i42[$N->M]=$N;$i46=ScopeFetcher::getInstance();$i46->addLeaveCallback(array($this,'leaveClass'),$i46->getDepth()+1);$Y->jump($i44);return 1024|4|1;}public function getCurrentClass(){return$this->i41;}public function leaveClass(){$this->i41=null;}public function fetchClass($M){$M=strtolower($M);switch($M){case"self":return$this->i41;case"parent":return$this->i41?$this->i41->P:null;default:return isset($this->i42[$M])?$this->i42[$M]:null;}}public function registerClass($M,ClassEntry$i47){$this->i42[$M]=$i47;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\ConstantContainer;class  ConstantDefinitionHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(335,$this);}public function execute(Token$S,TokenVM$Y){$r=$Y->getTokenArray();$i48=false;$N=ClassFetcher::getInstance()->getCurrentClass();while($i44=next($r)){switch($i44->b){case 16393:break 2;case 16394:$i48=true;case 375:continue 2;case 307:if($i48){if(ConstantContainer::isDefined($i44->content)){ConstantContainer::define($M,ConstantContainer::getConstant($i44->content),$N,true);}else {ConstantContainer::define($M,$i44->content,$N,true);}}else {$M=$i44->content;}break;case 305:ConstantContainer::define($M,(int)$i44->content,$N,true);break;case 306:ConstantContainer::define($M,(float)$i44->content,$N,true);break;case 16389:ConstantContainer::define($M,true,$N,true);break;case 16390:ConstantContainer::define($M,false,$N,true);break;case 315:ConstantContainer::define($M,eval('return ('.$i44->content.');'),$N,true);break;case 16388:$i48=false;}}$Y->jump($i44);return 1024|4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  NamespaceFetcher implements TokenHandler {private static$i4=null;private$i49=array("");public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(381,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==381){$r=$Y->getTokenArray();$O="";for($S=current($r);;$S=next($r)){switch($S->b){case 384:if($O)$O.="\\";break;case 307:$O.=strtolower($S->content);break;case 16393:$Y->registerTokenHandler(16397,$this);break 2;case 16395:$i46=ScopeFetcher::getInstance();$i46->addLeaveCallback(array($this,'leaveNamespace'),$i46->getDepth()+1);break 2;}}$this->i49[]=$O;$Y->jump($S);return 1024|4|1;}else {$this->leaveNamespace();if(count($this->i49)==1)$Y->unregisterTokenHandler(16397,$this);return 512|1;}}public function leaveNamespace(){end($this->i49);unset($this->i49[key($this->i49)]);}public function getCurrentNamespace(){return end($this->i49);}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ScopeFetcher implements TokenHandler {private static$i4=null;private$i50=0;private$i51=array();private$i52=array();public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(16395,$this);TokenVM::globalRegisterTokenHandler(16396,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==16395){$this->i50++;if(isset($this->i51[$this->i50])){foreach($this->i51[$this->i50]as$a=>$H){call_user_func($H,$this->i50);unset($this->i51[$a]);}}}else {if(isset($this->i52[$this->i50])){foreach($this->i52[$this->i50]as$a=>$H){call_user_func($H,$this->i50);unset($this->i52[$a]);}}$this->i50--;}return 4|1;}public function addEnterCallback($H,$i50){$this->i51[$i50][]=$H;}public function addLeaveCallback($H,$i50){$this->i52[$i50][]=$H;}public function getDepth(){return$this->i50;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;use Moody\ConstantContainer;use Moody\Configuration;use Moody\InstructionHandlers\Macro;use Moody\TokenHandlers\InstructionProcessor;class  SymbolSubstitutionHandler implements TokenHandler {private static$i4=null;private static$i=array(307,384,16398,16399);private$i29=false;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){Configuration::registerCallback('autosubstitutesymbols',true,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i29){$this->i29=false;if($F){foreach(self::$i as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i29){$this->i29=true;if($F){foreach(self::$i as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$i as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){$r=$Y->getTokenArray();$i53=0;$i54=$S;switch($S->b){case 16398:case 16399:$N=ClassFetcher::getInstance()->getCurrentClass();if($S->b==16399)$N=$N->P;for($i44=current($r);;$i44=next($r)){if($i44->b==380)continue;if($i44->b!=307)break 2;if(ConstantContainer::isDefined($i44->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i44->content,$N))){$S->content=Token::makeEvaluatable($L);$Y->jump(next($r));return 64|1;}break 2;}break;case 384:$S=current($r);next($r);case 307:$i55=$S->content;if($i56=Macro::getMacro(strtolower($i55))){$i8="";if($i56->numArgs()){$i57=0;for($i44=current($r);;$i44=next($r)){switch($i44->b){case 16386:$i57++;if($i57>1)$i8.=$i44->content;break;case 16387:if(!(--$i57))break 2;default:$i8.=$i44->content;}}$Y->moveTo(next($r));}InstructionProcessor::getInstance()->callInstruction($i56->M,$Y,0,array(),$i8);return 512|1;}for($i44=current($r);;$i44=next($r)){switch($i44->b){case 380:$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if(!$O||!($N=ClassFetcher::getInstance()->fetchClass($O."\\".$i55)))$N=ClassFetcher::getInstance()->fetchClass($i55);continue 2;case 307:if(isset($N)&&ConstantContainer::isDefined($i44->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i44->content,$N))){$i54->content=Token::makeEvaluatable($L);$Y->jump(next($r));return 64|1;}else {$i55.=$i44->content;continue 2;}case 384:$i55.="\\";continue 2;default:break 2;}}if(ConstantContainer::isDefined($i55)&&is_scalar($L=ConstantContainer::getConstant($i55))){$i54->content=Token::makeEvaluatable($L);$Y->jump($i44);return 1|64;}break;}return 1|4;}}}namespace  Moody\TokenHandlers {use Moody\ConstantContainer;use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  UseStatementParser implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(340,$this);}public function execute(Token$S,TokenVM$Y){$i58=ClassFetcher::getInstance();if($i58->getCurrentClass())return 4|1;$r=$Y->getTokenArray();$i43=340;$i59="";$i60="";for($i44=current($r);;$i44=next($r)){switch($i44->b){case 326:$i43=326;break;case 384:if($i43==326){if($i60)$i60.="\\";}else if($i59){$i59.="\\";}break;case 307:if($i43==326)$i60.=$i44->content;else $i59.=$i44->content;break;case 16388:case 16393:if(!($N=$i58->fetchClass($i59)))break 2;if($i43==340){$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O)$i60=$O."\\".$N->i40;else $i60=$N->i40;}$i58->registerClass(strtolower($i60),$N);if($i44->b==16388){$i60=$i59="";break;}break 2;}}$Y->jump($i44);return 1024|1;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  BooleanCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (bool)$i7[0];$S->content=Token::makeEvaluatable((bool)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  CallHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i61=$W;$i7=$X->parseArguments($S,$W,'');$i7=array_merge(array($i61),$i7);}else {$i7=$X->parseArguments($S,$W,'s');$i61=$i7[0];}if(strpos($i61,'::')){$i62=explode('::',$i61,2);$i61=array($i62[0],$i62[1]);if(!method_exists($i62[0],$i62[1]))throw new InstructionProcessorException($i7[0].'() does not exist',$S);}else if(!function_exists($i61))throw new InstructionProcessorException($i7[0].'() does not exist',$S);if(!is_callable($i61))throw new InstructionProcessorException($i7[0].'() is not callable from the current scope',$S);$i63=$i7;unset($i63[0]);$E=call_user_func_array($i61,$i63);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if(strpos($W,'::')){$i62=explode('::',$W,2);if(!method_exists($i62[0],$i62[1]))return false;}else if(!function_exists($W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ConfigurationHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s?x');if(!isset($i7[1])){if($Z&1)return Configuration::get($i7[0],null);$S->content=Token::makeEvaluatable(Configuration::get($i7[0],null));return 0;}else Configuration::set($i7[0],$i7[1],$Y);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GetConstantHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2)$i7=array($W);else $i7=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i7[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i7[0],$S);$i64=ConstantContainer::getConstant($i7[0]);if($Z&1)return$i64;$S->content=Token::makeEvaluatable($i64);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if($X->parseArguments($S,$W,''))return false;if(!ConstantContainer::isDefined($W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\ConstantContainer;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;class  DefineHandler implements InstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i7=$X->parseArguments($S,$W,'sx');$K=$W;$i65=array('(',')','+','-','*','/','|','&','^','>>','<<');$i66="";foreach($i7 as$i67=>$i68){if(!$i67)continue;if(!is_int($i68)&&!in_array($i68,$i65))$i69=false;$i66.=$i68;}if(isset($i69))$E=$i66;else if(($E=eval('return ('.$i66.');'))===false)throw new InstructionProcessorException('Math syntax error');switch($i7[0]){case'=':ConstantContainer::define($K,$E);break;case'.=':ConstantContainer::define($K,ConstantContainer::getConstant($K).$E);break;case'+=':ConstantContainer::define($K,ConstantContainer::getConstant($K)+$E);break;case'-=':ConstantContainer::define($K,ConstantContainer::getConstant($K)-$E);break;case'*=':ConstantContainer::define($K,ConstantContainer::getConstant($K)*$E);break;case'/=':ConstantContainer::define($K,ConstantContainer::getConstant($K)/$E);break;case'|=':ConstantContainer::define($K,ConstantContainer::getConstant($K)|$E);break;case'^=':ConstantContainer::define($K,ConstantContainer::getConstant($K)^$E);break;case'&=':ConstantContainer::define($K,ConstantContainer::getConstant($K)&$E);break;case'>>=':ConstantContainer::define($K,ConstantContainer::getConstant($K)>>$E);break;case'<<=':ConstantContainer::define($K,ConstantContainer::getConstant($K)<<$E);break;}}else {$i7=$X->parseArguments($S,$W,'sx');ConstantContainer::define($i7[0],$i7[1]);}return 512;}public function canExecute(Token$S,$W,InstructionProcessor$X){$i7=$X->parseArguments($S,$W,'');$i65=array('=','.=','+=','-=','*=','/=','|=','&=','^=','<<=','>>=');if($i7&&in_array($i7[0],$i65)&&!($i7[0]!='='&&!ConstantContainer::isDefined($W)))return true;return false;}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\ClassFetcher;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\TokenHandlers\ClassEntry;class  DumpClassEntryHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('dumpclassentry',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'?s');if($i7){$N=ClassFetcher::getInstance()->fetchClass($i7[0]);}else {$N=ClassFetcher::getInstance()->getCurrentClass();}if(!$N)throw new InstructionProcessorException('Unknown class specified',$S);$this->dumpClassEntry($N,"");}private function dumpClassEntry(ClassEntry$N,$i70){echo"Moody Class Entry ".$N->M." {".'
';if($N->P){echo$i70."Extends ";$this->dumpClassEntry($N->P,$i70."\t");}if($N->i39){echo$i70."Implements {".'
';foreach($N->i39 as$i71){echo$i70."\t".$i71.'
';}echo$i70."}".'
';}if($N->J){foreach($N->J as$M=>$E){echo$i70.$M." = ".$E.'
';}}echo$i70."}".'
';}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EchoHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'x');foreach($i7 as$i68)echo (string)$i68;return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getToken()==$S){if(!($h->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i72=$h;}}foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getEndToken()==$S){if($h->getEndTokenAction()==1){$i72->setEndTokenAction(1);$Y->jump($i72->getEndToken());return 512|64;}}}return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseIfHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getToken()==$S){if(!($h->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i72=$h;}}foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getEndToken()==$S){if($h->getEndTokenAction()==1){$i72->setEndTokenAction(1);$Y->jump($i72->getEndToken());return 512|64;}}}return IfHandler::getInstance()->execute($S,$W,$X,$Y);}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  EndLongDefineHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endlongdefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\InstructionProcessor;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenVM;use Moody\MultiTokenInstruction;class  EndIfHandler implements InstructionHandlerWithRegister {private static$i4;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EvalHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s?bb');if(!isset($i7[1])||$i7[1]===true){if(!strpos($i7[0],'<?')){$i73=true;$r=Token::tokenize('<?php '.$i7[0].' ?>',$W.' code');}else $r=Token::tokenize($i7[0],$W.' code');$Y=new TokenVM();$r=$Y->execute($r);if(isset($i73)){reset($r);unset($r[key($r)]);end($r);unset($r[key($r)]);}$i7[0]="";foreach($r as$i74){$i7[0].=$i74->content;}}$i75=eval($i7[0]);if($i75!==null){if($Z&1)return$i75;$S->content=!isset($i7[2])||$i7[2]===true?Token::makeEvaluatable($i75):$i75;return 0;}return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ExitHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 2|512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GotoHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');$i76=LabelHandler::getLabel($i7[0]);if(!($i76 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i7[0],$S);$Y->jump($i76);return 64|512;}}}namespace  Moody\InstructionHandlers {use Moody\END_TOKEN_ELSE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'x');foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getToken()==$S){if(!($h->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i77="";$i75=false;foreach($i7 as$i68){if(is_string($i68)&&strlen($i68)&&strtolower($i68)!=="true"&&strtolower($i68)!=="false"){$i=Token::tokenize('<?php '.$i68.' ?>');if($i[1]->b==307)$i68=Token::makeEvaluatable($i68);}else if(is_string($i68)&&!strlen($i68))$i68="''";if($i68===true)$i68="true";else if($i68===false)$i68="false";else if($i68===null)$i68="null";$i77.=$i68;}$i75=eval('return (int) (bool) ('.$i77.');');if($i75===1){$h->setEndTokenAction(1);return 512;}if($i75===false)throw new InstructionProcessorException('If-condition '.$i77.' is invalid',$S);$h->setEndTokenAction(2);$Y->jump($h->getEndToken());return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfDefHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getToken()==$S){if(!($h->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(ConstantContainer::isDefined($i7[0])){$h->setEndTokenAction(1);return 512;}$Y->jump($h->getEndToken());$h->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfNotDefHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$h){if($h->getToken()==$S){if(!($h->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(!ConstantContainer::isDefined($i7[0])){$h->setEndTokenAction(1);return 512;}$Y->jump($h->getEndToken());$h->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IncludeHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(!file_exists($i7[0]))throw new InstructionProcessorException($i7[0].' does not exist',$S);if(!is_readable($i7[0]))throw new InstructionProcessorException($i7[0].' is not readable - Make sure Moody has the rights to read it',$S);$l=file_get_contents($i7[0]);$i=Token::tokenize($l,$i7[0]);switch($i[0]->b){case 372:unset($i[0]);break;case 311:$S=new Token;$S->b=374;$S->content=" ?>";$i78=array($S);foreach($i as$S)$i78[]=$S;$i=$i78;}switch(end($i)->b){case 374:unset($i[key($i)]);break;case 311:$S=new Token;$S->b=372;$S->content="<?php ";$i[]=$S;}$S=new Token;$S->b=16397;$S->content=$i7[0];$i[]=$S;$Y->insertTokenArray($i);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  InputHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('input',$this);InstructionProcessor::getInstance()->registerHandler('getinput',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'?n');if(!defined('STDIN')||!is_resource(\STDIN))throw new InstructionProcessorException('No input stream available',$S);$E=fread(\STDIN,isset($i7[0])?$i7[0]:1024);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IsDefinedHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');if(ConstantContainer::isDefined($i7[0])){if($Z&1)return true;$S->content=Token::makeEvaluatable(true);}else {if($Z&1)return false;$S->content=Token::makeEvaluatable(false);}return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  LabelHandler implements InstructionHandlerWithRegister {private static$i4=null;private static$i79=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(isset(self::$i79[$i7[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i7[0].'" (first definition at '.self::$i79[$i7[0]]->d.':'.self::$i79[$i7[0]]->e,$S);self::$i79[$i7[0]]=$S;}public static function getLabel($M){if(isset(self::$i79[$M]))return self::$i79[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  LongDefineHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('longdefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('longDefine')as$h){if($h->getToken()==$S){$T=$h->getEndToken();if(!($T instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endLongDefine?',$S);$i=$Y->getTokenArray();$i80="";while($S=current($i)){if($S==$T){ConstantContainer::define($i7[0],$i80);$Y->jump($S);return 64|512;}$i80.=$S->content;next($i);}}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  MacroHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if(strtolower($W)=='macro'){if($Z&1)throw new InstructionProcessorException($W.' does not support inline execution',$S);$i7=$X->parseArguments($S,$W,'ss');if(!$i7[0])throw new InstructionProcessorException('Macro name cannot be empty',$S);$i7[0]=strtolower($i7[0]);$i56=new Macro($i7[0],$i7[1]);$X->registerHandler($i7[0],$this);unset($i7[0],$i7[1]);foreach($i7 as$i68)$i56->addArgument($i68);return 512;}$i56=Macro::getMacro($W);if(!$i56)throw new InstructionProcessorException('Call to bad macro',$S);$i13="";for($i81=0;$i81<$i56->numArgs();$i81++)$i13.='x';$i7=$X->parseArguments($S,$W,$i13);if($Z&1){$code="";foreach($i56->buildCode($i7)as$S)$code.=$S->content;return$code;}else $Y->insertTokenArray($i56->buildCode($i7));return 512;}}class  Macro {public$M="";private$code="";private$i82=array();private static$i83=array();public function __construct($M,$code){$this->M=$M;$this->code=$code;self::$i83[$M]=$this;}public function addArgument($i84){$this->i82[]=$i84;}public function numArgs(){return count($this->i82);}public function buildCode($i7=array()){$i81=0;$code=$this->code;foreach($this->i82 as$i68){$code=str_replace($i68,$i7[$i81],$code);$i81++;}$i=Token::tokenize('<?php '.$code,'Macro '.$this->M);unset($i[0]);return$i;}public static function getMacro($M){$M=strtolower($M);if(isset(self::$i83[$M]))return self::$i83[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenHandlers\VariableHandler;use Moody\TokenVM;class  MapVariableHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$S);VariableHandler::getInstance()->mapVariable($i7[0],$i7[1]);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  NumberCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (float)$i7[0];$S->content=Token::makeEvaluatable((float)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RaiseErrorHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');throw new InstructionProcessorException($i7[0],$S);}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RegisterConfigurationHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('registerconfiguration',$this);InstructionProcessor::getInstance()->registerHandler('registerconfig',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'sx');Configuration::set($i7[0],$i7[1]);}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  StringCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (string)$i7[0];$S->content=Token::makeEvaluatable((string)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  UndefineHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i7[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i7[0],$S);ConstantContainer::undefine($i7[0]);return 512;}}}?>