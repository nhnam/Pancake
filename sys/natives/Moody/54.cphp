<?php namespace  Moody {class  Configuration {private static$A=array();private static$B=array();public static function load($C){}public static function set($D,$E,TokenVM$F=null){$D=strtolower($D);if(isset(self::$B[$D])){call_user_func(self::$B[$D],$E,$F);}return self::$A[$D]=$E;}public static function get($D,$G=null){$D=strtolower($D);if(isset(self::$A[$D]))return self::$A[$D];return$G;}public static function registerCallback($D,$G,$H,$I=true){if(!is_callable($H)){throw new MoodyException('Bad configuration callback');}$D=strtolower($D);self::$B[$D]=$H;if($I){$H(isset(self::$A[$D])?self::$A[$D]:$G);}}}}namespace  Moody {use Moody\TokenHandlers\ClassEntry;use Moody\TokenHandlers\ClassFetcher;use Moody\TokenHandlers\NamespaceFetcher;class  ConstantContainer {private static$J=array();public static function initialize(){foreach(get_defined_constants()as$K=>$L)if(!self::isDefined($K))self::define($K,$L);}public static function getConstant($M,ClassEntry$N=null){$M=strtolower($M);if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return$N->J[$M[1]];}while($N=$N->P);}return;}if($N){do{if(isset($N->J[$M]))return$N->J[$M];}while($N=$N->P);return;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return self::$J[$O."\\".$M];if(isset(self::$J[$M]))return self::$J[$M];}public static function isDefined($M,ClassEntry$N=null){$M=strtolower($M);if($N){do{if(isset($N->J[$M]))return true;}while($N=$N->P);return false;}if(strpos($M,'::')){$M=explode('::',$M,2);if(!($O=NamespaceFetcher::getInstance()->getCurrentNamespace())||($O&&!($N=ClassFetcher::getInstance()->fetchClass($O.'\\'.$M[0])))){$N=ClassFetcher::getInstance()->fetchClass($M[0]);}if($N){do{if(isset($N->J[$M[1]]))return true;}while($N=$N->P);}return false;}$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O&&isset(self::$J[$O."\\".$M]))return true;return isset(self::$J[$M]);}public static function define($M,$E,ClassEntry$N=null,$O=false){if($N){$N->J[strtolower($M)]=$E;}else {if($O&&$O=NamespaceFetcher::getInstance()->getCurrentNamespace())$M=$O."\\".strtolower($M);else $M=strtolower($M);self::$J[$M]=$E;}}public static function undefine($M){$M=strtolower($M);if(isset(self::$J[$M]))unset(self::$J[$M]);}}}namespace  Moody {const  END_TOKEN_NO_EXECUTE = 1;const  END_TOKEN_EXECUTE = 2;class  MultiTokenInstruction {private static$Q=array();private static$R=array();private$S;private$T;private$U=2;public function __construct(Token$S,$N){self::$Q[$N][]=$this;self::$R[$N][]=$this;$this->S=$S;}public static function setEndToken(Token$S,$N){if(!isset(self::$R[$N])||!self::$R[$N])throw new InstructionProcessorException('End token of type '.$N.' while not active',$S);end(self::$R[$N]);self::$R[$N][key(self::$R[$N])]->T=$S;unset(self::$R[$N][key(self::$R[$N])]);}public function getToken(){return$this->S;}public function getEndToken(){return$this->T;}public function setEndTokenAction($V){$this->U=$V;}public function getEndTokenAction(){return$this->U;}public static function getAll($N){return self::$Q[$N];}}}namespace  Moody {interface InstructionHandler{public static function getInstance();public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y);}interface InlineInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);}interface DefaultInstructionHandler extends InstructionHandler{public function execute(Token$S,$W,TokenHandlers\InstructionProcessor$X,TokenVM$Y=null,$Z=0);public function canExecute(Token$S,$W,TokenHandlers\InstructionProcessor$X);}}namespace  Moody {class  InstructionProcessorException extends \Exception {private$S;public function __construct($message,Token$S){$this->message=$message;$this->S=$S;}public function __toString(){$C='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString()."\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;return$C;}}}namespace  Moody {class  MoodyException extends \Exception {public function __toString(){$C='Moody encountered an unexpected error and can not continue.'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace: '."\r\n".$this->getTraceAsString();return$C;}}}namespace  Moody {define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);define('T_EQUAL',16394);define('T_CURLY_BRACKET_OPEN',16395);define('T_CURLY_BRACKET_CLOSE',16396);define('T_EOF',16397);define('T_SELF',16398);define('T_PARENT',16399);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class  Token {public$a=0;public$b=0;public$c=0;public$d="Unknown";public$e=0;public$content="";public$f=array();private static$g=0;private static$h=0;private static$i=array(347=>"T_ABSTRACT",271=>"T_AND_EQUAL",362=>"T_ARRAY",292=>"T_ARRAY_CAST",326=>"T_AS",313=>"T_BAD_CHARACTER",279=>"T_BOOLEAN_AND",278=>"T_BOOLEAN_OR",290=>"T_BOOL_CAST",331=>"T_BREAK",329=>"T_CASE",338=>"T_CATCH",312=>"T_CHARACTER",354=>"T_CLASS",364=>"T_CLASS_C",298=>"T_CLONE",374=>"T_CLOSE_TAG",16388=>"T_COMMA",370=>"T_COMMENT",273=>"T_CONCAT_EQUAL",335=>"T_CONST",315=>"T_CONSTANT_ENCAPSED_STRING",332=>"T_CONTINUE",379=>"T_CURLY_OPEN",16395=>"T_CURLY_BRACKET_OPEN",16396=>"T_CURLY_BRACKET_CLOSE",296=>"T_DEC",324=>"T_DECLARE",330=>"T_DEFAULT",383=>"T_DIR",274=>"T_DIV_EQUAL",306=>"T_DNUMBER",317=>"T_DO",371=>"T_DOC_COMMENT",378=>"T_DOLLAR_OPEN_CURLY_BRACES",16384=>"T_DOT",360=>"T_DOUBLE_ARROW",294=>"T_DOUBLE_CAST",380=>"T_DOUBLE_COLON",316=>"T_ECHO",303=>"T_ELSE",302=>"T_ELSEIF",352=>"T_EMPTY",314=>"T_ENCAPSED_AND_WHITESPACE",325=>"T_ENDDECLARE",321=>"T_ENDFOR",323=>"T_ENDFOREACH",304=>"T_ENDIF",328=>"T_ENDSWITCH",319=>"T_ENDWHILE",377=>"T_END_HEREDOC",16397=>"T_EOF",16394=>"T_EQUAL",260=>"T_EVAL",300=>"T_EXIT",357=>"T_EXTENDS",16390=>"T_FALSE",369=>"T_FILE",346=>"T_FINAL",320=>"T_FOR",16392=>"T_FORCED_WHITESPACE",322=>"T_FOREACH",334=>"T_FUNCTION",367=>"T_FUNC_C",342=>"T_GLOBAL",333=>"T_GOTO",353=>"T_HALT_COMPILER",372=>"T_OPEN_TAG",16387=>"T_ROUND_BRACKET_CLOSE",16386=>"T_ROUND_BRACKET_OPEN",16393=>"T_SEMICOLON",307=>"T_STRING",16389=>"T_TRUE",16385=>"T_UNKNOWN",309=>"T_VARIABLE",375=>"T_WHITESPACE");public function __construct(){$this->a=self::$g++;}public static function tokenize($code,$j=null){$g=token_get_all($code);if(!$g)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$k=array();self::$h++;foreach($g as$S){$l=new Token;$l->c=self::$h;$l->d=$j;if(is_array($S)){$l->b=$S[0];$l->content=$S[1];$l->e=$S[2];switch(strtolower($l->content)){case'true':$l->b=16389;break;case'false':$l->b=16390;break;case'null':$l->b=16391;break;case'self':$l->b=16398;break;case'parent':$l->b=16399;break;}}else {$l->content=$S;$l->e=-1;switch($S){case'.':$l->b=16384;break;case'(':$l->b=16386;break;case')':$l->b=16387;break;case',':$l->b=16388;break;case';':$l->b=16393;break;case'=':$l->b=16394;break;case'{':$l->b=16395;break;case'}':$l->b=16396;break;default:$l->b=16385;}}$k[]=$l;}return$k;}public static function getName($m){return isset(self::$i[$m])?self::$i[$m]:$m;}public function __toString(){$C='Type: '.self::getName($this->b)."\r\n";$C.='Content: '.$this->content."\r\n";if($this->d!="Unknown"){$C.='Origin: '.$this->d."\r\n";$C.='Line: '.$this->e."\r\n";}return$C;}public static function makeEvaluatable($E){if(is_string($E))return"'".str_replace("'","\'",$E)."'";if(is_int($E)||is_float($E))return$E;if($E===true)return"true";if($E===false)return"false";if($E===null)return"null";}public static function makeTokenFromValue($E,$n="Moody Tokenizer Value"){$S=new Token;$S->d=$n;if($E instanceof Variable){$S->b=309;$S->content=$E->M;}else {$S->content=var_export($E,true);switch(gettype($E)){case"string":$S->b=315;break;case"integer":$S->b=305;break;case"double":$S->b=306;break;case"boolean":$S->b=$E?16389:16390;break;case"NULL":$S->b=16391;break;default:throw new MoodyException('Unsupported value of type '.gettype($E));}}return$S;}}}namespace  Moody {interface TokenHandler{public static function getInstance();public function execute(Token$S,TokenVM$Y);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$S,TokenVM$Y);}}namespace  Moody {const  MOODY_VERSION = "1.0";class  TokenVM {const  NEXT_TOKEN = 1;const  QUIT = 2;const  NEXT_HANDLER = 4;const  ERROR = 8;const  REEXECUTE_TOKEN = 16;const  REEXECUTE_HANDLER = 32;const  JUMP = 64;const  CLEAR_RETVAL = 128;const  CLEAR_ERROR = 256;const  DELETE_TOKEN = 512;const  JUMP_WITHOUT_DELETE_TOKEN = 1024;private static$o=array();private$p=array();private$q=array();private$r=null;public function __construct(){$this->p=self::$o;}public function execute($q){if(!$q)throw new VMException('Virtual machine received empty token array');$this->q=$q;foreach($this->q as$S){if(isset($this->p[$S->b])){foreach($this->p[$S->b]as$s){if(is_callable(array($s,'register'))){$t=clone$S;$s->register($S,$this);if($S!=$t)throw new VMException('Token corrupted in register step',$S,$t);}}reset($this->p[$S->b]);}}reset($this->q);$u=array();nextToken:if(!($S=current($this->q)))goto quit;$v=$S->a;next($this->q);executeToken:$w=0;nextHandler:if(isset($this->p[$S->b])){$s=current($this->p[$S->b]);next($this->p[$S->b]);}else {$u[]=$S;goto nextToken;}executeHandler:$x=$s->execute($S,$this);if($x&128)$w=$x;else $w|=$x;doRetval:if($w&32){$w^=32;goto executeHandler;}if($w&4){$w^=4;if(current($this->p[$S->b])!==false)goto nextHandler;}if($w&16){reset($this->p[$S->b]);$w^=16;goto executeToken;}if(!($w&512))$u[]=$S;if($w&2)goto quit;if($w&8&&!($w&256))throw new VMException('Token handler returned an error',$S);if(($w&64)||($w&1024)){if(!($this->r instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$S);if(!in_array($this->r,$this->q))throw new VMException('Cannot jump to new token as it is not specified in current token array',$S);$y=array_search($this->r,$this->q);if($y<key($this->q)){while(prev($this->q)!=$this->r);}else if($y>key($this->q)){if($w&1024){$u[]=current($this->q);while(($z=next($this->q))!=$this->r){$u[]=$z;}}else {while(next($this->q)!=$this->r);}}}if($w&1){reset($this->p[$S->b]);goto nextToken;}throw new VMException('Token handler did not specify an action for the virtual machine',$S);quit:return$u;}public static function globalRegisterTokenHandler($m,TokenHandler$i0){if(!($i0 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($m).' is invalid');if(!isset(self::$o[$m]))self::$o[$m]=array($i0);else self::$o[$m][]=$i0;}public static function globalUnregisterTokenHandler($m,TokenHandler$i0){if(!isset(self::$o[$m])||($y=array_search($i0,self::$o[$m]))===false)return;unset(self::$o[$m][$y]);if(!self::$o[$m])unset(self::$o[$m]);}public function registerTokenHandler($m,TokenHandler$i0){if(!($i0 instanceof TokenHandler))throw new VMException('Handler for token '.Token::getName($m).' is invalid');if(!isset($this->p[$m]))$this->p[$m]=array($i0);else $this->p[$m][]=$i0;}public function unregisterTokenHandler($m,TokenHandler$i0){if(!isset($this->p[$m])||($y=array_search($i0,$this->p[$m]))===false)return;unset($this->p[$m][$y]);if(!$this->p[$m])unset($this->p[$m]);}public function jump(Token$S){$this->r=$S;}public function insertTokenArray($q){reset($q);$i1=current($q);while($S=current($this->q)){$i2[]=$S;unset($this->q[key($this->q)]);}foreach($q as$S){if(isset($this->p[$S->b])){$i3=current($this->p[$S->b]);foreach($this->p[$S->b]as$s){if(is_callable(array($s,'register'))){$t=clone$S;$s->register($S,$this);if($S!=$t)throw new VMException('Token corrupted in register step',$S,$t);}}reset($this->p[$S->b]);if($i3!==current($this->p[$S->b])){while(next($this->p[$S->b])!==$i3);}}$this->q[]=$S;}foreach($i2 as$S)$this->q[]=$S;if(current($this->q)!==$i1){while(prev($this->q)!==$i1);}}public function getTokenArray(){return$this->q;}public function moveTo(Token$S){$y=array_search($S,$this->q);if($y<key($this->q)){while(prev($this->q)!=$S);}else if($y>key($this->q)){while(next($this->q)!=$S);}}}}namespace  Moody {class  VMException extends \Exception {private$S;public function __construct($message,Token$S=null){$this->message=$message;$this->S=$S;}public function __toString(){$C='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$C.='Exception message: '.$this->message."\r\n";$C.='System backtrace:'."\r\n";$C.=$this->getTraceAsString();if($this->S instanceof Token){$C.="\r\n";$C.='Current token:'."\r\n";$C.=(string)$this->S;}return$C;}}}namespace  Moody\TokenHandlers {use Moody\InstructionHandlerWithRegister;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\TokenHandlerWithRegister;use Moody\TokenVM;use Moody\Token;use Moody\InstructionProcessorException;use Moody\Configuration;use Moody\ConstantContainer;use Moody\InstructionHandler;class  InstructionProcessor implements TokenHandlerWithRegister {private static$i4=null;private$p=array();private$i5=array();const  EXECUTE_TYPE_INLINE = 1;const  EXECUTE_TYPE_DEFAULT = 2;public static function getInstance(){if(!self::$i4)new self;return self::$i4;}private function __construct(){self::$i4=$this;TokenVM::globalRegisterTokenHandler(370,$this);foreach(get_declared_classes()as$N){if(in_array('Moody\InstructionHandler',class_implements($N)))$N::getInstance();}}public function callInstruction($W,TokenVM$Y,$i6=0,$i7=array(),$i8=""){$S=new Token;$S->b=370;$S->content="#.".$W." ".$i8;$S->d="Moody Instruction Processor Direct Call";$S->f=$i7;return$i6==1?$this->inlineExecute($S):$this->execute($S,$Y);}public function execute(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();$i10=0;if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){$i11=strtolower($i9[1]);if(substr($i11,0,1)=='.')$i11=substr($i11,1);if(isset($this->p[$i11])){$i10=$this->p[$i11]->execute($S,$i9[1],$this,$Y);$S->f=array();goto end;}else if($this->i5){foreach($this->i5 as$i0){if($i0->canExecute($S,$i9[1],$this)){$i10=$i0->execute($S,$i9[1],$this,$Y,2);$S->f=array();goto end;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i9[1].'"',$S);}else if(Configuration::get('deletecomments',true))$i10=512;end:return (4|1)^$i10;}public function register(Token$S,TokenVM$Y){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){$i11=strtolower($i9[1]);if(substr($i11,0,1)=='.')$i11=substr($i11,1);if(isset($this->p[$i11])&&$this->p[$i11]instanceof InstructionHandlerWithRegister){$this->p[$i11]->register($S,$i9[1],$this,$Y);$S->f=array();}}}private function inlineExecute(Token$S){$content=str_replace(array("//","/*","*/","#"),"",$S->content);$i9=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$i9)){$i11=strtolower($i9[1]);if(substr($i11,0,1)=='.')$i11=substr($i11,1);if(isset($this->p[$i11])){if(!($this->p[$i11]instanceof InlineInstructionHandler))throw new InstructionProcessorException($i9[1].' does not support inline execution',$S);$w=$this->p[$i11]->execute($S,$i9[1],$this,null,1);$S->f=array();return$w;}else if($this->i5){foreach($this->i5 as$i0){if(!($i0 instanceof InlineInstructionHandler))continue;if($i0->canExecute($S,$i9[1],$this)){$w=$i0->execute($S,$i9[1],$this,null,2|1);$S->f=array();return$w;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$i9[1].'"',$S);}}public function registerHandler($i11,InstructionHandler$i0){if(!($i0 instanceof InstructionHandler))throw new InstructionProcessorException('Handler for instruction "'.$i11.'" is invalid');$this->p[$i11]=$i0;}public function registerDefaultHandler(DefaultInstructionHandler$i0){if(!($i0 instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default handler '.get_class($i0).' is invalid');$this->i5[]=$i0;}public function parseArguments(Token$i12,$W,$i13){if($i12->f)return$i12->f;if($i13)$i14=str_split($i13);else $i14=array();if(!strpos($i12->content,$W))throw new InstructionProcessorException('Token corrupted',$i12);if(substr($i12->content,0,2)=='/*')$content=substr($i12->content,2,strrpos($i12->content,'*/')-2);else if(substr($i12->content,0,1)=='#')$content=substr($i12->content,1);else $content=substr($i12->content,2);$i15=substr($content,strpos($content,$W)+strlen($W));$g=Token::tokenize('<?php '.$i15.' ?>','Moody Argument Parser');foreach($g as$S)if($S->b==16388)$i16=true;$i17=0;$i18=0;$i7=$i19=array();$i20=null;parseArgs:foreach($g as$S){if(isset($i21))goto parseArg;if($S->b==372||$S->b==374||$S->b==16386||$S->b==16387||$S->b==375||in_array($S,$i19))continue;switch($S->b){case 307:if(($i22=current($g))&&$i22->b==380){$i23=next($g);$i24=$S->content."::".$i23->content;if(ConstantContainer::isDefined($i24)){if($i20!==null)$i20.=ConstantContainer::getConstant($i24);else $i20=ConstantContainer::getConstant($i24);$i19=array($i22,$i23);break;}}if(ConstantContainer::isDefined($S->content))if($i20!==null)$i20.=ConstantContainer::getConstant($S->content);else $i20=ConstantContainer::getConstant($S->content);else $i20.=$S->content;break;case 315:$i20.=eval('return '.$S->content.';');break;case 16389:if($i20!==null)$i20.=true;else $i20=true;break;case 16390:if($i20!==null)$i20.=false;else $i20=false;break;case 305:if($i20!==null)$i20.=(int)$S->content;else $i20=(int)$S->content;break;case 306:if($i20!==null)$i20.=(float)$S->content;else $i20=(float)$S->content;break;case 16391:if($i20!==null)$i20.=null;else $i20=null;break;case 384:$i25="";$i26=prev($g);if($i26&&$i26->b==307){$i25=$i26->content.$S->content;end($i7);unset($i7[key($i7)]);next($g);}while($i27=next($g)){if($i27->b!=384&&$i27->b!=307&&$i27->b!=380)break;$i25.=$i27->content;$i19[]=$i27;}if(ConstantContainer::isDefined($i25))if($i20!==null)$i20.=ConstantContainer::getConstant($i25);else $i20=ConstantContainer::getConstant($i25);else $i20.=$i25;break;case 370:if($i20!==null)$i20.=$this->inlineExecute($S);else $i20=$this->inlineExecute($S);break;case 16388:goto parseArg;default:if($i20!==null)$i20.=$S->content;else $i20=$S->content;}if(isset($i16))continue;parseArg:if(!isset($i14[$i17+$i18])||!$i14[$i17+$i18]){$i7[]=$i20;}else if($i14[$i17+$i18]=='?'){$i18++;goto parseArg;}else {switch(strtolower($i14[$i17+$i18])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i14[$i17+$i18],$i12);case'n':if(is_numeric($i20)&&is_string($i20))$i7[]=(float)$i20;else if(is_int($i20)||is_float($i20)||$i20===null)$i7[]=$i20;else throw new InstructionProcessorException('Illegal argument '.($i17+1).' for '.$W.': '.gettype($i20).' '.(string)$i20.' given, number expected',$i12);break;case's':if(is_string($i20)||$i20===null)$i7[]=$i20;else throw new InstructionProcessorException('Illegal argument '.($i17+1).' for '.$W.': '.gettype($i20).' '.(string)$i20.' given, string expected',$i12);break;case'b':if(is_bool($i20)||$i20===null)$i7[]=$i20;else throw new InstructionProcessorException('Illegal argument '.($i17+1).' for '.$W.': '.gettype($i20).' '.(string)$i20.' given, bool expected',$i12);break;case'x':$i7[]=$i20;}}$i20=null;$i17++;if(isset($i21))break;}if($i20!==null){$i21=true;goto parseArgs;}if((strpos($i13,'?')!==false&&$i17<strpos($i13,'?'))||($i17<count($i14)&&strpos($i13,'?')===false))throw new InstructionProcessorException($W.' expects '.count($i14).' arguments, '.$i17.' given',$i12);return$i12->f=$i7;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  DocCommentHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(371,$this);}public function execute(Token$S,TokenVM$Y){if(Configuration::get('deletecomments',false))return 4|1|512;return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  EOFDeleter implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(16397,$this);}public function execute(Token$S,TokenVM$Y){return 512|1;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;class  OpenTagHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(372,$this);}public function execute(Token$S,TokenVM$Y){if($S->content=='<?'||$S->content=='<%')$S->content='<?php ';return 4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class  VariableHandler implements TokenHandler {private static$i4=null;private static$g=array(309,359);private$i28=array();private$i29="A";private$i30=false;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){Configuration::registerCallback('compressvariables',false,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i30){$this->i30=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i30){$this->i30=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){static$i31=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(!in_array($S->content,$i31)){if($S->b==359){if(!Configuration::get('compressproperties',false))return 4|1;$q=$Y->getTokenArray();$i32=current($q);if($i32->b!=307)goto end;while($i33=next($q)){if($i33->b==375)continue;if($i33->b==16386)goto end;break;}$i34=$i32;$i34->content='$'.$i34->content;}else $i34=$S;if(!isset($this->i28[$i34->content])){if(!Configuration::get('compressproperties',false)){$q=$Y->getTokenArray();prev($q);while($i33=prev($q)){switch($i33->b){case 348:$i35=true;goto map;default:if(!isset($i35)&&isset($i36))goto end;goto map;case 343:case 344:case 345:$i36=true;case 375:case 16392:continue 2;}}}map:do{$this->mapVariable($i34->content,is_int($this->i29)?'$i'.$this->i29:'$'.$this->i29);if($this->i29==="Z")$this->i29="a";else if($this->i29==="z")$this->i29=0;else if(is_int($this->i29))$this->i29++;else $this->i29=chr(ord($this->i29)+1);}while(count(array_keys($this->i28,$this->i28[$i34->content]))>1);}$i34->content=isset($i32)?substr($this->i28[$i34->content],1):$this->i28[$i34->content];}end:return 4|1;}public function mapVariable($i37,$i38){return$this->i28[$i37]=$i38;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Configuration;use Moody\Token;class  WhitespaceHandler implements TokenHandler {private static$i4=null;private$i30=false;private static$g=array(375,316,309,333,303,381,335,299,288,341,307,354,357,343,344,345,346,348,334,336,329,376,16393,377,331,332,340,339,356,355,358);public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){Configuration::registerCallback('deletewhitespaces',false,array($this,'invoke'));}}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i30){$this->i30=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i30){$this->i30=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){switch($S->b){case 375:$q=$Y->getTokenArray();if(($i33=current($q))&&$i33->b==377)$this->insertForcedWhitespace($Y,true);return 4|1|512;case 316:case 336:case 343:case 344:case 345:case 348:case 346:case 329:case 332:case 331:case 339:$q=$Y->getTokenArray();if($i33=current($q)){if($i33->b!=375)return 4|1;else if(($i33=next($q))&&$i33->b!=315&&$i33->b!=309)$this->insertForcedWhitespace($Y);}break;case 309:$q=$Y->getTokenArray();if($i33=current($q)){if($i33->b!=375)return 4|1;else if(($i33=next($q))&&($i33->b==326||$i33->b==288))$this->insertForcedWhitespace($Y);}break;case 333:case 381:case 335:case 299:case 288:case 341:case 354:case 357:case 334:case 376:case 340:case 356:case 355:case 358:$this->insertForcedWhitespace($Y);break;case 303:$q=$Y->getTokenArray();if($i33=current($q)){if($i33->b!=375)return 4|1;else if(($i33=next($q))&&$i33->b!=379)$this->insertForcedWhitespace($Y);}break;case 307:$q=$Y->getTokenArray();if($i33=current($q)){if($i33->b!=375)return 4|1;else if(($i33=next($q))&&($i33->b==357||$i33->b==341||$i33->b==288||$i33->b==326||$i33->b==358))$this->insertForcedWhitespace($Y);}break;case 16393:$q=$Y->getTokenArray();prev($q);$i33=prev($q);if($i33->b==377)$this->insertForcedWhitespace($Y,true);break;case 377:$q=$Y->getTokenArray();if(($i33=current($q))&&$i33->b!=16393)$this->insertForcedWhitespace($Y,true);break;}end:return 4|1;}private function insertForcedWhitespace(TokenVM$Y,$i39=false){$S=new Token;$S->content=$i39?"\r\n":" ";$S->b=16392;$S->d="Moody WhitespaceHandler";$Y->insertTokenArray(array($S));}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ClassEntry {public$i40=array();public$M="";public$i41="";public$P=null;public$J=array();}class  ClassFetcher implements TokenHandler {private static$i4=null;private$i42=null;private$i43=array();public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(354,$this);}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i44=354;$N=new ClassEntry;while($i45=next($q)){switch($i45->b){case 358:$i44=358;break;case 357:$i44=357;break;case 307:switch($i44){case 354:$i46=strtolower($i45->content);if($O=NamespaceFetcher::getInstance()->getCurrentNamespace())$N->M=$O."\\".$i46;else $N->M=$i46;$N->i41=$i46;break;case 357:$N->P=$this->fetchClass(strtolower($i45->content));break;case 358:$N->i40[]=strtolower($i45->content);}break;case 16395:break 2;}}$this->i42=$this->i43[$N->M]=$N;$i47=ScopeFetcher::getInstance();$i47->addLeaveCallback(array($this,'leaveClass'),$i47->getDepth()+1);$Y->jump($i45);return 1024|4|1;}public function getCurrentClass(){return$this->i42;}public function leaveClass(){$this->i42=null;}public function fetchClass($M){$M=strtolower($M);switch($M){case"self":return$this->i42;case"parent":return$this->i42?$this->i42->P:null;default:return isset($this->i43[$M])?$this->i43[$M]:null;}}public function registerClass($M,ClassEntry$i48){$this->i43[$M]=$i48;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\ConstantContainer;class  ConstantDefinitionHandler implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(335,$this);}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i49=false;$N=ClassFetcher::getInstance()->getCurrentClass();while($i45=next($q)){switch($i45->b){case 16393:break 2;case 16394:$i49=true;case 375:continue 2;case 307:if($i49){if(ConstantContainer::isDefined($i45->content)){ConstantContainer::define($M,ConstantContainer::getConstant($i45->content),$N,true);}else {ConstantContainer::define($M,$i45->content,$N,true);}}else {$M=$i45->content;}break;case 305:ConstantContainer::define($M,(int)$i45->content,$N,true);break;case 306:ConstantContainer::define($M,(float)$i45->content,$N,true);break;case 16389:ConstantContainer::define($M,true,$N,true);break;case 16390:ConstantContainer::define($M,false,$N,true);break;case 315:ConstantContainer::define($M,eval('return ('.$i45->content.');'),$N,true);break;case 16388:$i49=false;}}$Y->jump($i45);return 1024|4|1;}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  NamespaceFetcher implements TokenHandler {private static$i4=null;private$i50=array("");public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(381,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==381){$q=$Y->getTokenArray();$O="";for($S=current($q);;$S=next($q)){switch($S->b){case 384:if($O)$O.="\\";break;case 307:$O.=strtolower($S->content);break;case 16393:$Y->registerTokenHandler(16397,$this);break 2;case 16395:$i47=ScopeFetcher::getInstance();$i47->addLeaveCallback(array($this,'leaveNamespace'),$i47->getDepth()+1);break 2;}}$this->i50[]=$O;$Y->jump($S);return 1024|4|1;}else {$this->leaveNamespace();if(count($this->i50)==1)$Y->unregisterTokenHandler(16397,$this);return 512|1;}}public function leaveNamespace(){end($this->i50);unset($this->i50[key($this->i50)]);}public function getCurrentNamespace(){return end($this->i50);}}}namespace  Moody\TokenHandlers {use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  ScopeFetcher implements TokenHandler {private static$i4=null;private$i51=0;private$i52=array();private$i53=array();public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(16395,$this);TokenVM::globalRegisterTokenHandler(16396,$this);}public function execute(Token$S,TokenVM$Y){if($S->b==16395){$this->i51++;if(isset($this->i52[$this->i51])){foreach($this->i52[$this->i51]as$a=>$H){call_user_func($H,$this->i51);unset($this->i52[$a]);}}}else {if(isset($this->i53[$this->i51])){foreach($this->i53[$this->i51]as$a=>$H){call_user_func($H,$this->i51);unset($this->i53[$a]);}}$this->i51--;}return 4|1;}public function addEnterCallback($H,$i51){$this->i52[$i51][]=$H;}public function addLeaveCallback($H,$i51){$this->i53[$i51][]=$H;}public function getDepth(){return$this->i51;}}}namespace  Moody\TokenHandlers {use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;use Moody\ConstantContainer;use Moody\Configuration;use Moody\InstructionHandlers\Macro;use Moody\TokenHandlers\InstructionProcessor;class  SymbolSubstitutionHandler implements TokenHandler {private static$i4=null;private static$g=array(307,384,16398,16399);private$i30=false;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){Configuration::registerCallback('autosubstitutesymbols',true,array($this,'invoke'));}public function invoke($E,TokenVM$F=null){if(!$E&&$this->i30){$this->i30=false;if($F){foreach(self::$g as$S)$F->unregisterTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalUnregisterTokenHandler($S,$this);}}else if($E&&!$this->i30){$this->i30=true;if($F){foreach(self::$g as$S)$F->registerTokenHandler($S,$this);}else {foreach(self::$g as$S)TokenVM::globalRegisterTokenHandler($S,$this);}}}public function execute(Token$S,TokenVM$Y){$q=$Y->getTokenArray();$i54=0;$i55=$S;switch($S->b){case 16398:case 16399:$N=ClassFetcher::getInstance()->getCurrentClass();if($S->b==16399)$N=$N->P;for($i45=current($q);;$i45=next($q)){if($i45->b==380)continue;if($i45->b!=307)break 2;if(ConstantContainer::isDefined($i45->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i45->content,$N))){$S->content=Token::makeEvaluatable($L);$Y->jump(next($q));return 64|1;}break 2;}break;case 384:$S=current($q);next($q);case 307:$i56=$S->content;if($i57=Macro::getMacro(strtolower($i56))){$i8="";if($i57->numArgs()){$i58=0;for($i45=current($q);;$i45=next($q)){switch($i45->b){case 16386:$i58++;if($i58>1)$i8.=$i45->content;break;case 16387:if(!(--$i58))break 2;default:$i8.=$i45->content;}}$Y->moveTo(next($q));}InstructionProcessor::getInstance()->callInstruction($i57->M,$Y,0,array(),$i8);return 512|1;}for($i45=current($q);;$i45=next($q)){switch($i45->b){case 380:$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if(!$O||!($N=ClassFetcher::getInstance()->fetchClass($O."\\".$i56)))$N=ClassFetcher::getInstance()->fetchClass($i56);continue 2;case 307:if(isset($N)&&ConstantContainer::isDefined($i45->content,$N)&&is_scalar($L=ConstantContainer::getConstant($i45->content,$N))){$i55->content=Token::makeEvaluatable($L);$Y->jump(next($q));return 64|1;}else {$i56.=$i45->content;continue 2;}case 384:$i56.="\\";continue 2;default:break 2;}}if(ConstantContainer::isDefined($i56)&&is_scalar($L=ConstantContainer::getConstant($i56))){$i55->content=Token::makeEvaluatable($L);$Y->jump($i45);return 1|64;}break;}return 1|4;}}}namespace  Moody\TokenHandlers {use Moody\ConstantContainer;use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;class  UseStatementParser implements TokenHandler {private static$i4=null;public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}private function __construct(){TokenVM::globalRegisterTokenHandler(340,$this);}public function execute(Token$S,TokenVM$Y){$i59=ClassFetcher::getInstance();if($i59->getCurrentClass())return 4|1;$q=$Y->getTokenArray();$i44=340;$i60="";$i61="";for($i45=current($q);;$i45=next($q)){switch($i45->b){case 326:$i44=326;break;case 384:if($i44==326){if($i61)$i61.="\\";}else if($i60){$i60.="\\";}break;case 307:if($i44==326)$i61.=$i45->content;else $i60.=$i45->content;break;case 16388:case 16393:if(!($N=$i59->fetchClass($i60)))break 2;if($i44==340){$O=NamespaceFetcher::getInstance()->getCurrentNamespace();if($O)$i61=$O."\\".$N->i41;else $i61=$N->i41;}$i59->registerClass(strtolower($i61),$N);if($i45->b==16388){$i61=$i60="";break;}break 2;}}$Y->jump($i45);return 1024|1;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  BooleanCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (bool)$i7[0];$S->content=Token::makeEvaluatable((bool)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  CallHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i62=substr($W,0,1)=='.'?substr($W,1):$W;$i7=$X->parseArguments($S,$W,'');$i7=array_merge(array($i62),$i7);}else {$i7=$X->parseArguments($S,$W,'s');$i62=$i7[0];}if(strpos($i62,'::')){$i63=explode('::',$i62,2);$i62=array($i63[0],$i63[1]);if(!method_exists($i63[0],$i63[1]))throw new InstructionProcessorException($i7[0].'() does not exist',$S);}else if(!function_exists($i62))throw new InstructionProcessorException($i7[0].'() does not exist',$S);if(!is_callable($i62))throw new InstructionProcessorException($i7[0].'() is not callable from the current scope',$S);$i64=$i7;unset($i64[0]);$E=call_user_func_array($i62,$i64);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if(substr($W,0,1)=='.')$W=substr($W,1);if(strpos($W,'::')){$i63=explode('::',$W,2);if(!method_exists($i63[0],$i63[1]))return false;}else if(!function_exists($W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ConfigurationHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s?x');if(!isset($i7[1])){if($Z&1)return Configuration::get($i7[0],null);$S->content=Token::makeEvaluatable(Configuration::get($i7[0],null));return 0;}else Configuration::set($i7[0],$i7[1],$Y);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GetConstantHandler implements InlineInstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2)$i7=array($W[0]=='.'?substr($W,1):$W);else $i7=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i7[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i7[0],$S);$i65=ConstantContainer::getConstant($i7[0]);if($Z&1)return$i65;$S->content=Token::makeEvaluatable($i65);return 0;}public function canExecute(Token$S,$W,InstructionProcessor$X){if($X->parseArguments($S,$W,''))return false;if(!ConstantContainer::isDefined($W[0]=='.'?substr($W,1):$W))return false;return true;}}}namespace  Moody\InstructionHandlers {use Moody\DefaultInstructionHandler;use Moody\ConstantContainer;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;class  DefineHandler implements InstructionHandler, DefaultInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if($Z&2){$i7=$X->parseArguments($S,$W,'sx');$K=substr($W,0,1)=='.'?substr($W,1):$W;$i66=array('(',')','+','-','*','/','|','&','^','>>','<<');$i67="";foreach($i7 as$i68=>$i69){if(!$i68)continue;if(!is_int($i69)&&!in_array($i69,$i66))$i70=false;$i67.=$i69;}if(isset($i70))$E=$i67;else if(($E=eval('return ('.$i67.');'))===false)throw new InstructionProcessorException('Math syntax error');switch($i7[0]){case'=':ConstantContainer::define($K,$E);break;case'.=':ConstantContainer::define($K,ConstantContainer::getConstant($K).$E);break;case'+=':ConstantContainer::define($K,ConstantContainer::getConstant($K)+$E);break;case'-=':ConstantContainer::define($K,ConstantContainer::getConstant($K)-$E);break;case'*=':ConstantContainer::define($K,ConstantContainer::getConstant($K)*$E);break;case'/=':ConstantContainer::define($K,ConstantContainer::getConstant($K)/$E);break;case'|=':ConstantContainer::define($K,ConstantContainer::getConstant($K)|$E);break;case'^=':ConstantContainer::define($K,ConstantContainer::getConstant($K)^$E);break;case'&=':ConstantContainer::define($K,ConstantContainer::getConstant($K)&$E);break;case'>>=':ConstantContainer::define($K,ConstantContainer::getConstant($K)>>$E);break;case'<<=':ConstantContainer::define($K,ConstantContainer::getConstant($K)<<$E);break;}}else {$i7=$X->parseArguments($S,$W,'sx');ConstantContainer::define($i7[0],$i7[1]);}return 512;}public function canExecute(Token$S,$W,InstructionProcessor$X){$i7=$X->parseArguments($S,$W,'');$i66=array('=','.=','+=','-=','*=','/=','|=','&=','^=','<<=','>>=');if($i7&&in_array($i7[0],$i66)&&!($i7[0]!='='&&!ConstantContainer::isDefined(substr($W,0,1)=='.'?substr($W,1):$W)))return true;return false;}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\ClassFetcher;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\TokenHandlers\ClassEntry;class  DumpClassEntryHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('dumpclassentry',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'?s');if($i7){$N=ClassFetcher::getInstance()->fetchClass($i7[0]);}else {$N=ClassFetcher::getInstance()->getCurrentClass();}if(!$N)throw new InstructionProcessorException('Unknown class specified',$S);$this->dumpClassEntry($N,"");}private function dumpClassEntry(ClassEntry$N,$i71){echo"Moody Class Entry ".$N->M." {".'
';if($N->P){echo$i71."Extends ";$this->dumpClassEntry($N->P,$i71."\t");}if($N->i40){echo$i71."Implements {".'
';foreach($N->i40 as$i72){echo$i71."\t".$i72.'
';}echo$i71."}".'
';}if($N->J){foreach($N->J as$M=>$E){echo$i71.$M." = ".$E.'
';}}echo$i71."}".'
';}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EchoHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'x');foreach($i7 as$i69)echo (string)$i69;return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getToken()==$S){if(!($i11->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i73=$i11;}}foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getEndToken()==$S){if($i11->getEndTokenAction()==1){$i73->setEndTokenAction(1);$Y->jump($i73->getEndToken());return 512|64;}}}return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ElseIfHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getToken()==$S){if(!($i11->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i73=$i11;}}foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getEndToken()==$S){if($i11->getEndTokenAction()==1){$i73->setEndTokenAction(1);$Y->jump($i73->getEndToken());return 512|64;}}}return IfHandler::getInstance()->execute($S,$W,$X,$Y);}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  EndLongDefineHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endlongdefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\TokenHandlers\InstructionProcessor;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenVM;use Moody\MultiTokenInstruction;class  EndIfHandler implements InstructionHandlerWithRegister {private static$i4;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){MultiTokenInstruction::setEndToken($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  EvalHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s?bb');if(!isset($i7[1])||$i7[1]===true){if(!strpos($i7[0],'<?')){$i74=true;$q=Token::tokenize('<?php '.$i7[0].' ?>',$W.' code');}else $q=Token::tokenize($i7[0],$W.' code');$Y=new TokenVM();$q=$Y->execute($q);if(isset($i74)){reset($q);unset($q[key($q)]);end($q);unset($q[key($q)]);}$i7[0]="";foreach($q as$i75){$i7[0].=$i75->content;}}$i76=eval($i7[0]);if($i76!==null){if($Z&1)return$i76;$S->content=!isset($i7[2])||$i7[2]===true?Token::makeEvaluatable($i76):$i76;return 0;}return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  ExitHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 2|512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  GotoHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');$i77=LabelHandler::getLabel($i7[0]);if(!($i77 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i7[0],$S);$Y->jump($i77);return 64|512;}}}namespace  Moody\InstructionHandlers {use Moody\END_TOKEN_ELSE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'x');foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getToken()==$S){if(!($i11->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);$i78="";$i76=false;foreach($i7 as$i69){if(is_string($i69)&&strlen($i69)&&strtolower($i69)!=="true"&&strtolower($i69)!=="false"){$g=Token::tokenize('<?php '.$i69.' ?>');if($g[1]->b==307)$i69=Token::makeEvaluatable($i69);}else if(is_string($i69)&&!strlen($i69))$i69="''";if($i69===true)$i69="true";else if($i69===false)$i69="false";else if($i69===null)$i69="null";$i78.=$i69;}$i76=eval('return (int) (bool) ('.$i78.');');if($i76===1){$i11->setEndTokenAction(1);return 512;}if($i76===false)throw new InstructionProcessorException('If-condition '.$i78.' is invalid',$S);$i11->setEndTokenAction(2);$Y->jump($i11->getEndToken());return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfDefHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getToken()==$S){if(!($i11->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(ConstantContainer::isDefined($i7[0])){$i11->setEndTokenAction(1);return 512;}$Y->jump($i11->getEndToken());$i11->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IfNotDefHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('if')as$i11){if($i11->getToken()==$S){if(!($i11->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endif?',$S);if(!ConstantContainer::isDefined($i7[0])){$i11->setEndTokenAction(1);return 512;}$Y->jump($i11->getEndToken());$i11->setEndTokenAction(2);return 64|512;}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'if');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IncludeHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(!file_exists($i7[0]))throw new InstructionProcessorException($i7[0].' does not exist',$S);if(!is_readable($i7[0]))throw new InstructionProcessorException($i7[0].' is not readable - Make sure Moody has the rights to read it',$S);$j=file_get_contents($i7[0]);$g=Token::tokenize($j,$i7[0]);switch($g[0]->b){case 372:unset($g[0]);break;case 311:$S=new Token;$S->b=374;$S->content=" ?>";$i79=array($S);foreach($g as$S)$i79[]=$S;$g=$i79;}switch(end($g)->b){case 374:unset($g[key($g)]);break;case 311:$S=new Token;$S->b=372;$S->content="<?php ";$g[]=$S;}$S=new Token;$S->b=16397;$S->content=$i7[0];$g[]=$S;$Y->insertTokenArray($g);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  InputHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('input',$this);InstructionProcessor::getInstance()->registerHandler('getinput',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'?n');if(!defined('STDIN')||!is_resource(\STDIN))throw new InstructionProcessorException('No input stream available',$S);$E=fread(\STDIN,isset($i7[0])?$i7[0]:1024);if($Z&1)return$E;$S->content=Token::makeEvaluatable($E);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  IsDefinedHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');if(ConstantContainer::isDefined($i7[0])){if($Z&1)return true;$S->content=Token::makeEvaluatable(true);}else {if($Z&1)return false;$S->content=Token::makeEvaluatable(false);}return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  LabelHandler implements InstructionHandlerWithRegister {private static$i4=null;private static$i80=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(isset(self::$i80[$i7[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i7[0].'" (first definition at '.self::$i80[$i7[0]]->d.':'.self::$i80[$i7[0]]->e,$S);self::$i80[$i7[0]]=$S;}public static function getLabel($M){if(isset(self::$i80[$M]))return self::$i80[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class  LongDefineHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('longdefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');foreach(MultiTokenInstruction::getAll('longDefine')as$i11){if($i11->getToken()==$S){$T=$i11->getEndToken();if(!($T instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$W.' - Probably you forgot an endLongDefine?',$S);$g=$Y->getTokenArray();$i81="";while($S=current($g)){if($S==$T){ConstantContainer::define($i7[0],$i81);$Y->jump($S);return 64|512;}$i81.=$S->content;next($g);}}}return 8;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){new MultiTokenInstruction($S,'longDefine');}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  MacroHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){if(strtolower($W)=='.macro'){if($Z&1)throw new InstructionProcessorException($W.' does not support inline execution',$S);$i7=$X->parseArguments($S,$W,'ss');if(!strlen($i7[0]))throw new InstructionProcessorException('Macro name cannot be empty',$S);$i7[0]=strtolower($i7[0]);$i57=new Macro($i7[0],$i7[1]);$X->registerHandler($i7[0],$this);unset($i7[0],$i7[1]);foreach($i7 as$i69)$i57->addArgument($i69);return 512;}$i82=substr(strtolower($W),1);$i57=Macro::getMacro($i82);if(!$i57)throw new InstructionProcessorException('Call to bad macro',$S);$i14="";for($i83=0;$i83<$i57->numArgs();$i83++)$i14.='x';$i7=$X->parseArguments($S,$W,$i14);if($Z&1){$code="";foreach($i57->buildCode($i7)as$S)$code.=$S->content;return$code;}else $Y->insertTokenArray($i57->buildCode($i7));return 512;}}class  Macro {public$M="";private$code="";private$i84=array();private static$i85=array();public function __construct($M,$code){$this->M=$M;$this->code=$code;self::$i85[$M]=$this;}public function addArgument($i86){$this->i84[]=$i86;}public function numArgs(){return count($this->i84);}public function buildCode($i7=array()){$i83=0;$code=$this->code;foreach($this->i84 as$i69){$code=str_replace($i69,$i7[$i83],$code);$i83++;}$g=Token::tokenize('<?php '.$code,'Macro '.$this->M);unset($g[0]);return$g;}public static function getMacro($M){if(isset(self::$i85[$M]))return self::$i85[$M];}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenHandlers\VariableHandler;use Moody\TokenVM;class  MapVariableHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$S);VariableHandler::getInstance()->mapVariable($i7[0],$i7[1]);return 512;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  NumberCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (float)$i7[0];$S->content=Token::makeEvaluatable((float)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RaiseErrorHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'s');throw new InstructionProcessorException($i7[0],$S);}}}namespace  Moody\InstructionHandlers {use Moody\Configuration;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  RegisterConfigurationHandler implements InstructionHandlerWithRegister {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('registerconfiguration',$this);InstructionProcessor::getInstance()->registerHandler('registerconfig',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){return 512;}public function register(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'sx');Configuration::set($i7[0],$i7[1]);}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  StringCastHandler implements InlineInstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y=null,$Z=0){$i7=$X->parseArguments($S,$W,'x');if($Z&1)return (string)$i7[0];$S->content=Token::makeEvaluatable((string)$i7[0]);return 0;}}}namespace  Moody\InstructionHandlers {use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class  UndefineHandler implements InstructionHandler {private static$i4=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$i4)self::$i4=new self;return self::$i4;}public function execute(Token$S,$W,InstructionProcessor$X,TokenVM$Y){$i7=$X->parseArguments($S,$W,'s');if(!ConstantContainer::isDefined($i7[0]))throw new InstructionProcessorException($W.': Undefined constant: '.$i7[0],$S);ConstantContainer::undefine($i7[0]);return 512;}}}?>